{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1040\deflangfe1040{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}{\f14\fnil\fcharset2\fprq2{\*\panose 05000000000000000000}Wingdings;}
{\f28\fswiss\fcharset0\fprq2{\*\panose 020b0604030504040204}Verdana;}{\f86\froman\fcharset238\fprq2 Times New Roman CE;}{\f87\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f89\froman\fcharset161\fprq2 Times New Roman Greek;}
{\f90\froman\fcharset162\fprq2 Times New Roman Tur;}{\f91\froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f92\froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f93\froman\fcharset186\fprq2 Times New Roman Baltic;}
{\f94\fswiss\fcharset238\fprq2 Arial CE;}{\f95\fswiss\fcharset204\fprq2 Arial Cyr;}{\f97\fswiss\fcharset161\fprq2 Arial Greek;}{\f98\fswiss\fcharset162\fprq2 Arial Tur;}{\f99\fswiss\fcharset177\fprq2 Arial (Hebrew);}
{\f100\fswiss\fcharset178\fprq2 Arial (Arabic);}{\f101\fswiss\fcharset186\fprq2 Arial Baltic;}{\f102\fmodern\fcharset238\fprq1 Courier New CE;}{\f103\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f105\fmodern\fcharset161\fprq1 Courier New Greek;}
{\f106\fmodern\fcharset162\fprq1 Courier New Tur;}{\f107\fmodern\fcharset177\fprq1 Courier New (Hebrew);}{\f108\fmodern\fcharset178\fprq1 Courier New (Arabic);}{\f109\fmodern\fcharset186\fprq1 Courier New Baltic;}
{\f310\fswiss\fcharset238\fprq2 Verdana CE;}{\f311\fswiss\fcharset204\fprq2 Verdana Cyr;}{\f313\fswiss\fcharset161\fprq2 Verdana Greek;}{\f314\fswiss\fcharset162\fprq2 Verdana Tur;}{\f317\fswiss\fcharset186\fprq2 Verdana Baltic;}}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;
\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 
\fs24\lang1040\langfe1040\cgrid\langnp1040\langfenp1040 \snext0 Normal;}{\s2\ql \li0\ri0\sb100\sa100\sbauto1\saauto1\widctlpar\aspalpha\aspnum\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\f1\fs48\lang1040\langfe1040\cgrid\langnp1040\langfenp1040 
\sbasedon0 \snext2 heading 2;}{\s3\ql \li0\ri0\sb100\sa80\sbauto1\widctlpar\aspalpha\aspnum\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \b\f1\fs41\lang1040\langfe1040\cgrid\langnp1040\langfenp1040 \sbasedon0 \snext3 heading 3;}{\*\cs10 \additive 
Default Paragraph Font;}{\s15\ql \li0\ri0\widctlpar\tqc\tx4819\tqr\tx9638\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1040\langfe1040\cgrid\langnp1040\langfenp1040 \sbasedon0 \snext15 header;}{\s16\ql \li0\ri0\widctlpar
\tqc\tx4819\tqr\tx9638\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1040\langfe1040\cgrid\langnp1040\langfenp1040 \sbasedon0 \snext16 footer;}{\s17\ql \li0\ri0\widctlpar
\tx916\tx1832\tx2748\tx3664\tx4580\tx5496\tx6412\tx7328\tx8244\tx9160\tx10076\tx10992\tx11908\tx12824\tx13740\tx14656\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1040\langfe1040\loch\f2\hich\af2\dbch\af2\cgrid\langnp1040\langfenp1040 
\sbasedon0 \snext17 HTML Preformatted;}{\*\cs18 \additive \b\fs38 \sbasedon10 dropcap;}{\*\cs19 \additive \b\i \sbasedon10 bigoh;}{\s20\ql \li0\ri0\sb100\sa100\sbauto1\saauto1\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 
\fs24\lang1040\langfe1040\cgrid\langnp1040\langfenp1040 \sbasedon0 \snext20 Normal (Web);}{\*\cs21 \additive \b\fs29\loch\f2\hich\af2\dbch\af2 \sbasedon10 HTML Code;}{\*\cs22 \additive \ul\cf0 \sbasedon10 Hyperlink;}{
\s23\qc \li0\ri0\sb100\sa100\sbauto1\saauto1\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1040\langfe1040\cgrid\langnp1040\langfenp1040 \sbasedon0 \snext23 center;}{
\s24\qr \li0\ri0\sb100\sa100\sbauto1\saauto1\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1040\langfe1040\cgrid\langnp1040\langfenp1040 \sbasedon0 \snext24 right;}{
\s25\qj \li0\ri0\sb100\sa100\sbauto1\saauto1\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1040\langfe1040\cgrid\langnp1040\langfenp1040 \sbasedon0 \snext25 justify;}{
\s26\ql \li0\ri0\sb100\sa100\sbauto1\saauto1\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\f1\fs48\lang1040\langfe1040\cgrid\langnp1040\langfenp1040 \sbasedon0 \snext26 doctitle;}{
\s27\qj \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \f28\fs18\lang1040\langfe1040\cgrid\langnp1040\langfenp1040 \sbasedon0 \snext27 Body Text;}{\*\cs28 \additive \sbasedon10 page number;}{
\s29\qc \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\lang1040\langfe1040\cgrid\langnp1040\langfenp1040 \sbasedon0 \snext29 Title;}{\s30\ql \li720\ri0\sb100\sa100\sbauto1\saauto1\sl240\slmult0
\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin720\itap0 \f28\fs18\lang1040\langfe1040\cgrid\langnp1040\langfenp1040 \sbasedon0 \snext30 Body Text 2;}}{\*\listtable{\list\listtemplateid84201712\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0
\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157441\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li720\jclisttab\tx720 }{\listlevel\levelnfc23
\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157443\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li1440\jclisttab\tx1440 }{\listlevel
\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157445\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2160
\jclisttab\tx2160 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157441\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 
\fi-360\li2880\jclisttab\tx2880 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157443\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 
\chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li3600\jclisttab\tx3600 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157445\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr
\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li4320\jclisttab\tx4320 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157441
\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5040\jclisttab\tx5040 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext
\leveltemplateid68157443\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5760\jclisttab\tx5760 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0
{\leveltext\leveltemplateid68157445\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li6480\jclisttab\tx6480 }{\listname ;}\listid75252770}{\list\listtemplateid1395945384\listhybrid{\listlevel
\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157441\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li720\jclisttab\tx720 
}{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157443\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li1440
\jclisttab\tx1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157445\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 
\chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2160\jclisttab\tx2160 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157441\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr
\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2880\jclisttab\tx2880 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157443\'01o;}{\levelnumbers;}\f2
\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li3600\jclisttab\tx3600 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157445
\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li4320\jclisttab\tx4320 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext
\leveltemplateid68157441\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5040\jclisttab\tx5040 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360
\levelindent0{\leveltext\leveltemplateid68157443\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5760\jclisttab\tx5760 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1
\levelspace360\levelindent0{\leveltext\leveltemplateid68157445\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li6480\jclisttab\tx6480 }{\listname ;}\listid123550280}{\list\listtemplateid2019208846
\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157441\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 
\fi-360\li720\jclisttab\tx720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157443\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 
\chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li1440\jclisttab\tx1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157445\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr
\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2160\jclisttab\tx2160 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157441
\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2880\jclisttab\tx2880 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext
\leveltemplateid68157443\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li3600\jclisttab\tx3600 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0
{\leveltext\leveltemplateid68157445\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li4320\jclisttab\tx4320 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1
\levelspace360\levelindent0{\leveltext\leveltemplateid68157441\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5040\jclisttab\tx5040 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0
\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157443\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5760\jclisttab\tx5760 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0
\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157445\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li6480\jclisttab\tx6480 }{\listname ;}\listid143014343}
{\list\listtemplateid1995457234\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157441\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 
\chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li720\jclisttab\tx720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157443\'01o;}{\levelnumbers;}\f2\chbrdr
\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li1440\jclisttab\tx1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157445
\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2160\jclisttab\tx2160 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext
\leveltemplateid68157441\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2880\jclisttab\tx2880 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360
\levelindent0{\leveltext\leveltemplateid68157443\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li3600\jclisttab\tx3600 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1
\levelspace360\levelindent0{\leveltext\leveltemplateid68157445\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li4320\jclisttab\tx4320 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0
\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157441\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5040\jclisttab\tx5040 }{\listlevel\levelnfc23\levelnfcn23
\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157443\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5760\jclisttab\tx5760 }{\listlevel\levelnfc23
\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157445\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li6480\jclisttab\tx6480 }
{\listname ;}\listid143741284}{\list\listtemplateid84201712\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157451\'01\u-3880 ?;}{\levelnumbers;}\f14\chbrdr
\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li720\jclisttab\tx720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157443\'01o;}{\levelnumbers;}\f2
\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li1440\jclisttab\tx1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157445
\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2160\jclisttab\tx2160 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext
\leveltemplateid68157441\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2880\jclisttab\tx2880 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360
\levelindent0{\leveltext\leveltemplateid68157443\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li3600\jclisttab\tx3600 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1
\levelspace360\levelindent0{\leveltext\leveltemplateid68157445\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li4320\jclisttab\tx4320 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0
\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157441\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5040\jclisttab\tx5040 }{\listlevel\levelnfc23\levelnfcn23
\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157443\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5760\jclisttab\tx5760 }{\listlevel\levelnfc23
\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157445\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li6480\jclisttab\tx6480 }
{\listname ;}\listid202133651}{\list\listtemplateid1496849704\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid-276783958\'01\u-3913 ?;}{\levelnumbers;}\f3\fs20
\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li720\jclisttab\tx720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid-1387872060\'01o;}{\levelnumbers
;}\f2\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li1440\jclisttab\tx1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid-1138469864
\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2160\jclisttab\tx2160 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext
\leveltemplateid-1442965304\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2880\jclisttab\tx2880 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0
\levelindent0{\leveltext\leveltemplateid214866594\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li3600\jclisttab\tx3600 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0
\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid-1368209336\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li4320\jclisttab\tx4320 }{\listlevel\levelnfc23\levelnfcn23\leveljc0
\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid274524382\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5040\jclisttab\tx5040 }{\listlevel\levelnfc23
\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid780853734\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5760\jclisttab\tx5760 }
{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid-647584262\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 
\fi-360\li6480\jclisttab\tx6480 }{\listname ;}\listid205335682}{\list\listtemplateid1395945384\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157451
\'01\u-3880 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li720\jclisttab\tx720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext
\leveltemplateid68157443\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li1440\jclisttab\tx1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0
{\leveltext\leveltemplateid68157445\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2160\jclisttab\tx2160 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1
\levelspace360\levelindent0{\leveltext\leveltemplateid68157441\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2880\jclisttab\tx2880 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0
\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157443\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li3600\jclisttab\tx3600 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0
\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157445\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li4320\jclisttab\tx4320 }{\listlevel\levelnfc23\levelnfcn23
\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157441\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5040\jclisttab\tx5040 }{\listlevel
\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157443\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5760\jclisttab\tx5760 }
{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157445\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li6480
\jclisttab\tx6480 }{\listname ;}\listid273250396}{\list\listtemplateid1265520630\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid-36120122
\'01\u-3913 ?;}{\levelnumbers;}\f3\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li720\jclisttab\tx720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext
\leveltemplateid1103924992\'01o;}{\levelnumbers;}\f2\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li1440\jclisttab\tx1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0
{\leveltext\leveltemplateid-1939725328\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2160\jclisttab\tx2160 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1
\levelspace0\levelindent0{\leveltext\leveltemplateid-40886984\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2880\jclisttab\tx2880 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0
\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid933022638\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li3600\jclisttab\tx3600 }{\listlevel\levelnfc23\levelnfcn23
\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid-1882296202\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li4320\jclisttab\tx4320 }{\listlevel
\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid-90828460\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5040
\jclisttab\tx5040 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid61389214\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 
\chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5760\jclisttab\tx5760 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid1415905152\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20
\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li6480\jclisttab\tx6480 }{\listname ;}\listid401371868}{\list\listtemplateid2019208846\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1
\levelspace360\levelindent0{\leveltext\leveltemplateid68157451\'01\u-3880 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li720\jclisttab\tx720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0
\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157443\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li1440\jclisttab\tx1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0
\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157445\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2160\jclisttab\tx2160 }{\listlevel\levelnfc23\levelnfcn23
\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157441\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2880\jclisttab\tx2880 }{\listlevel
\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157443\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li3600\jclisttab\tx3600 }
{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157445\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li4320
\jclisttab\tx4320 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157441\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 
\fi-360\li5040\jclisttab\tx5040 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157443\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 
\chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5760\jclisttab\tx5760 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157445\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr
\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li6480\jclisttab\tx6480 }{\listname ;}\listid560948510}{\list\listtemplateid236848950\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0
\levelindent0{\leveltext\leveltemplateid68157441\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li720\jclisttab\tx720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1
\levelspace0\levelindent0{\leveltext\leveltemplateid68157443\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li1440\jclisttab\tx1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0
\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid68157445\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2160\jclisttab\tx2160 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0
\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid68157441\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2880\jclisttab\tx2880 }{\listlevel\levelnfc23\levelnfcn23
\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid68157443\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li3600\jclisttab\tx3600 }{\listlevel\levelnfc23
\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid68157445\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li4320\jclisttab\tx4320 }
{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid68157441\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5040
\jclisttab\tx5040 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid68157443\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 
\fi-360\li5760\jclisttab\tx5760 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid68157445\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 
\chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li6480\jclisttab\tx6480 }{\listname ;}\listid634944486}{\list\listtemplateid1878972756\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext
\leveltemplateid-51608468\'02\'00.;}{\levelnumbers\'01;}\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 \fi-360\li720\jclisttab\tx720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext
\leveltemplateid-1486217950\'02\'01.;}{\levelnumbers\'01;}\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 \fi-360\li1440\jclisttab\tx1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0
{\leveltext\leveltemplateid609096616\'02\'02.;}{\levelnumbers\'01;}\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 \fi-360\li2160\jclisttab\tx2160 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0
\levelindent0{\leveltext\leveltemplateid1474883266\'02\'03.;}{\levelnumbers\'01;}\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 \fi-360\li2880\jclisttab\tx2880 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1
\levelspace0\levelindent0{\leveltext\leveltemplateid411592872\'02\'04.;}{\levelnumbers\'01;}\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 \fi-360\li3600\jclisttab\tx3600 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0
\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid-2043256286\'02\'05.;}{\levelnumbers\'01;}\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 \fi-360\li4320\jclisttab\tx4320 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0
\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid931400994\'02\'06.;}{\levelnumbers\'01;}\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 \fi-360\li5040\jclisttab\tx5040 }{\listlevel\levelnfc0\levelnfcn0\leveljc0
\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid399955838\'02\'07.;}{\levelnumbers\'01;}\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 \fi-360\li5760\jclisttab\tx5760 }{\listlevel\levelnfc0\levelnfcn0
\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid2000696778\'02\'08.;}{\levelnumbers\'01;}\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 \fi-360\li6480\jclisttab\tx6480 }{\listname ;}\listid1240671755
}{\list\listtemplateid1020437114\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid-1945738910\'01\u-3913 ?;}{\levelnumbers;}\f3\fs20\chbrdr\brdrnone\brdrcf1 
\chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li720\jclisttab\tx720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid1450354422\'01o;}{\levelnumbers;}\f2\fs20\chbrdr
\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li1440\jclisttab\tx1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid-1297438890
\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2160\jclisttab\tx2160 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext
\leveltemplateid-67087098\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2880\jclisttab\tx2880 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0
\levelindent0{\leveltext\leveltemplateid1488748500\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li3600\jclisttab\tx3600 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0
\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid1495851798\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li4320\jclisttab\tx4320 }{\listlevel\levelnfc23\levelnfcn23\leveljc0
\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid1819705490\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5040\jclisttab\tx5040 }{\listlevel\levelnfc23
\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid-871602974\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5760\jclisttab\tx5760 }
{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid-1628672594\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 
\fi-360\li6480\jclisttab\tx6480 }{\listname ;}\listid1553810937}{\list\listtemplateid933116866\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid-712864330
\'01\u-3913 ?;}{\levelnumbers;}\f3\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li720\jclisttab\tx720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext
\leveltemplateid739303044\'01o;}{\levelnumbers;}\f2\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li1440\jclisttab\tx1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0
{\leveltext\leveltemplateid-340759434\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2160\jclisttab\tx2160 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1
\levelspace0\levelindent0{\leveltext\leveltemplateid1551422508\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2880\jclisttab\tx2880 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0
\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid1426765686\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li3600\jclisttab\tx3600 }{\listlevel\levelnfc23
\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid-1406739178\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li4320\jclisttab\tx4320 }
{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid1308816880\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 
\fi-360\li5040\jclisttab\tx5040 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid-1967729192\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 
\chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5760\jclisttab\tx5760 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid2028368262\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20
\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li6480\jclisttab\tx6480 }{\listname ;}\listid1655183772}{\list\listtemplateid822632054\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1
\levelspace360\levelindent0{\leveltext\leveltemplateid68157441\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li720\jclisttab\tx720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0
\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157443\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li1440\jclisttab\tx1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0
\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157445\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2160\jclisttab\tx2160 }{\listlevel\levelnfc23\levelnfcn23
\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157441\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2880\jclisttab\tx2880 }{\listlevel
\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157443\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li3600\jclisttab\tx3600 }
{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157445\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li4320
\jclisttab\tx4320 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157441\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 
\fi-360\li5040\jclisttab\tx5040 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157443\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 
\chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5760\jclisttab\tx5760 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid68157445\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr
\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li6480\jclisttab\tx6480 }{\listname ;}\listid1751464123}{\list\listtemplateid236848950\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360
\levelindent0{\leveltext\leveltemplateid68157451\'01\u-3880 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li720\jclisttab\tx720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1
\levelspace0\levelindent0{\leveltext\leveltemplateid68157443\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li1440\jclisttab\tx1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0
\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid68157445\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2160\jclisttab\tx2160 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0
\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid68157441\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2880\jclisttab\tx2880 }{\listlevel\levelnfc23\levelnfcn23
\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid68157443\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li3600\jclisttab\tx3600 }{\listlevel\levelnfc23
\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid68157445\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li4320\jclisttab\tx4320 }
{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid68157441\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5040
\jclisttab\tx5040 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid68157443\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 
\fi-360\li5760\jclisttab\tx5760 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid68157445\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 
\chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li6480\jclisttab\tx6480 }{\listname ;}\listid1768967474}{\list\listtemplateid-476963908\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0
{\leveltext\leveltemplateid1586032648\'01\u-3913 ?;}{\levelnumbers;}\f3\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li720\jclisttab\tx720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1
\levelspace0\levelindent0{\leveltext\leveltemplateid719249120\'01o;}{\levelnumbers;}\f2\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li1440\jclisttab\tx1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0
\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid-189367754\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2160\jclisttab\tx2160 }{\listlevel\levelnfc23\levelnfcn23\leveljc0
\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid-348384424\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2880\jclisttab\tx2880 }{\listlevel\levelnfc23
\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid1618259704\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li3600\jclisttab\tx3600 }
{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid-890487024\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 
\fi-360\li4320\jclisttab\tx4320 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid-1556690156\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 
\chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5040\jclisttab\tx5040 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid1163683088\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20
\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5760\jclisttab\tx5760 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid-1630527514
\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li6480\jclisttab\tx6480 }{\listname ;}\listid1777555521}{\list\listtemplateid-1349762402\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0
\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid1009947928\'01\u-3913 ?;}{\levelnumbers;}\f3\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li720\jclisttab\tx720 }{\listlevel\levelnfc23
\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid1150868890\'01o;}{\levelnumbers;}\f2\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li1440\jclisttab\tx1440 }{\listlevel
\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid-101405342\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2160
\jclisttab\tx2160 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid830493782\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 
\chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2880\jclisttab\tx2880 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid26148312\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr
\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li3600\jclisttab\tx3600 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid-283479722
\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li4320\jclisttab\tx4320 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext
\leveltemplateid-1975879014\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5040\jclisttab\tx5040 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0
\levelindent0{\leveltext\leveltemplateid-761887866\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5760\jclisttab\tx5760 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0
\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid277091424\'01\u-3929 ?;}{\levelnumbers;}\f14\fs20\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li6480\jclisttab\tx6480 }{\listname ;}\listid1913007085}}
{\*\listoverridetable{\listoverride\listid1655183772\listoverridecount0\ls1}{\listoverride\listid1553810937\listoverridecount0\ls2}{\listoverride\listid401371868\listoverridecount0\ls3}{\listoverride\listid1240671755\listoverridecount0\ls4}
{\listoverride\listid1777555521\listoverridecount0\ls5}{\listoverride\listid205335682\listoverridecount0\ls6}{\listoverride\listid1913007085\listoverridecount0\ls7}{\listoverride\listid123550280\listoverridecount0\ls8}{\listoverride\listid143014343
\listoverridecount0\ls9}{\listoverride\listid75252770\listoverridecount0\ls10}{\listoverride\listid143741284\listoverridecount0\ls11}{\listoverride\listid1751464123\listoverridecount0\ls12}{\listoverride\listid634944486\listoverridecount0\ls13}
{\listoverride\listid273250396\listoverridecount0\ls14}{\listoverride\listid560948510\listoverridecount0\ls15}{\listoverride\listid202133651\listoverridecount0\ls16}{\listoverride\listid1768967474\listoverridecount0\ls17}}{\*\revtbl {Unknown;}}{\info
{\title Listati algoritmi di ordinamento}{\author Ignazio Infantino}{\operator Ignazio Infantino}{\creatim\yr2002\mo3\dy4\hr14\min33}{\revtim\yr2002\mo3\dy4\hr14\min33}{\version2}{\edmins5}{\nofpages51}{\nofwords12054}{\nofchars68710}{\*\company Cogito}
{\nofcharsws84380}{\vern8249}}\paperw11906\paperh16838\margl1134\margr1134\margt1417\margb1134 \deftab708\widowctrl\ftnbj\aenddoc\hyphhotz283\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\formshade\horzdoc\dgmargin\dghspace180\dgvspace180
\dghorigin1134\dgvorigin1417\dghshow1\dgvshow1\jexpand\viewkind1\viewscale75\pgbrdrhead\pgbrdrfoot\splytwnine\ftnlytwnine\htmautsp\nolnhtadjtbl\useltbaln\alntblind\lytcalctblwd\lyttblrtgr\lnbrkrule \fet0\sectd 
\linex0\headery708\footery708\colsx708\endnhere\sectlinegrid360\sectdefaultcl {\header \pard\plain \s15\ql \li0\ri0\widctlpar\tqc\tx4819\tqr\tx9638\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1040\langfe1040\cgrid\langnp1040\langfenp1040 
{\i Fondamenti di Informatica  (A.A. 2001-02)  \tab                                                             Ing.I. Infantino}{
\par }}{\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}
{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8
\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 
\fs24\lang1040\langfe1040\cgrid\langnp1040\langfenp1040 {\b\f1\fs20 /*Listati algoritmi di ordinamento*/
\par }{\f1\fs20 
\par }\pard\plain \s17\ql \li0\ri0\widctlpar\tx916\tx1832\tx2748\tx3664\tx4580\tx5496\tx6412\tx7328\tx8244\tx9160\tx10076\tx10992\tx11908\tx12824\tx13740\tx14656\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1040\langfe1040\loch\af2\hich\af2\dbch\af2\cgrid\langnp1040\langfenp1040 {\b\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 /* insert sort */
\par }{\f1\lang2057\langfe1040\langnp2057 
\par \hich\af1\dbch\af2\loch\f1 #include <stdio.h>
\par \hich\af1\dbch\af2\loch\f1 #include <stdlib.h>
\par 
\par \hich\af1\dbch\af2\loch\f1 typedef int T;          /* type of item to be sorted */
\par \hich\af1\dbch\af2\loch\f1 typedef int tblIndex;   /* type of subscript */
\par 
\par }{\f1 \hich\af1\dbch\af2\loch\f1 #define compGT(a,b) (a > b)
\par 
\par }{\f1\lang1031\langfe1040\langnp1031 \hich\af1\dbch\af2\loch\f1 void insertSort(T *a, tblInde\hich\af1\dbch\af2\loch\f1 x lb, tblIndex ub) \{
\par \hich\af1\dbch\af2\loch\f1     T t;
\par \hich\af1\dbch\af2\loch\f1     tblIndex i, j;
\par 
\par \hich\af1\dbch\af2\loch\f1    }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 /**************************
\par \hich\af1\dbch\af2\loch\f1     *  sort array a[lb..ub]  *
\par \hich\af1\dbch\af2\loch\f1     **************************/
\par \hich\af1\dbch\af2\loch\f1     for (i = lb + 1; i <= ub; i++) \{
\par \hich\af1\dbch\af2\loch\f1         }{\f1 \hich\af1\dbch\af2\loch\f1 t = a[i];
\par 
\par \hich\af1\dbch\af2\loch\f1         }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 /* Shift elements down until */
\par \hich\af1\dbch\af2\loch\f1         /* inser\hich\af1\dbch\af2\loch\f1 tion point found.    */
\par \hich\af1\dbch\af2\loch\f1         for (j = i-1; j >= lb && compGT(a[j], t); j--)
\par \hich\af1\dbch\af2\loch\f1             a[j+1] = a[j];
\par 
\par \hich\af1\dbch\af2\loch\f1         /* insert */
\par \hich\af1\dbch\af2\loch\f1         a[j+1] = t;
\par \hich\af1\dbch\af2\loch\f1     \}
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 void fill(T *a, tblIndex lb, tblIndex ub) \{
\par \hich\af1\dbch\af2\loch\f1     tblIndex i;
\par \hich\af1\dbch\af2\loch\f1     srand(1);
\par \hich\af1\dbch\af2\loch\f1     for (i = lb; i <= ub;\hich\af1\dbch\af2\loch\f1  i++) a[i] = rand();
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 int main(int argc, char *argv[]) \{
\par \hich\af1\dbch\af2\loch\f1     tblIndex maxnum, lb, ub;
\par \hich\af1\dbch\af2\loch\f1     T *a;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* command-line: ins maxnum
\par \hich\af1\dbch\af2\loch\f1      *               ins 2000
\par \hich\af1\dbch\af2\loch\f1      *                 sorts 2000 records  */
\par 
\par \hich\af1\dbch\af2\loch\f1     maxnum = atoi(argv[1]);
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang1031\langfe1040\langnp1031 \hich\af1\dbch\af2\loch\f1 lb = 0; ub = max\hich\af1\dbch\af2\loch\f1 num - 1;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 if ((a = malloc(maxnum * sizeof(T))) == 0) \{
\par \hich\af1\dbch\af2\loch\f1         fprintf (stderr, "insufficient memory (a)\\n");
\par \hich\af1\dbch\af2\loch\f1         exit(1);
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     fill(a, lb, ub);
\par \hich\af1\dbch\af2\loch\f1     insertSort(a, lb, ub);
\par 
\par \hich\af1\dbch\af2\loch\f1     return 0;
\par }{\f1 \}
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1040\langfe1040\cgrid\langnp1040\langfenp1040 {\f1\fs20 
\par 
\par 
\par }\pard\plain \s17\ql \li0\ri0\widctlpar\tx916\tx1832\tx2748\tx3664\tx4580\tx5496\tx6412\tx7328\tx8244\tx9160\tx10076\tx10992\tx11908\tx12824\tx13740\tx14656\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1040\langfe1040\loch\af2\hich\af2\dbch\af2\cgrid\langnp1040\langfenp1040 {\f1\lang2057\langfe1040\langnp2057 
\par }{\b\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 /* shell sort */
\par }{\f1\lang2057\langfe1040\langnp2057 
\par \hich\af1\dbch\af2\loch\f1 #include <stdio.h>
\par \hich\af1\dbch\af2\loch\f1 #include <stdl\hich\af1\dbch\af2\loch\f1 ib.h>
\par 
\par \hich\af1\dbch\af2\loch\f1 typedef int T;          /* type of item to be sorted */
\par \hich\af1\dbch\af2\loch\f1 typedef int tblIndex;   /* type of subscript */
\par 
\par }{\f1 \hich\af1\dbch\af2\loch\f1 #define compGT(a,b) (a > b)
\par 
\par }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 void shellSort(T *a, tblIndex lb, tblIndex ub) \{
\par \hich\af1\dbch\af2\loch\f1     tblIndex n, h, i, j;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 T t;
\par 
\par \hich\af1\dbch\af2\loch\f1    /**************************
\par \hich\af1\dbch\af2\loch\f1     *  sort array a[lb..ub]  *
\par \hich\af1\dbch\af2\loch\f1     **************************/
\par 
\par \hich\af1\dbch\af2\loch\f1     /* compute largest increment */
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang1031\langfe1040\langnp1031 \hich\af1\dbch\af2\loch\f1 n = ub - lb + 1;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 h = 1;
\par \hich\af1\dbch\af2\loch\f1     if (n < 14)
\par \hich\af1\dbch\af2\loch\f1         h = 1;
\par \hich\af1\dbch\af2\loch\f1     else if (sizeof(tblIndex) == 2 && n > 29524)
\par \hich\af1\dbch\af2\loch\f1         h = 3280;
\par \hich\af1\dbch\af2\loch\f1     else \{
\par \hich\af1\dbch\af2\loch\f1         while (\hich\af1\dbch\af2\loch\f1 h < n) h = 3*h + 1;
\par \hich\af1\dbch\af2\loch\f1         h /= 3;
\par \hich\af1\dbch\af2\loch\f1         h /= 3;
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     while (h > 0) \{
\par 
\par \hich\af1\dbch\af2\loch\f1         /* sort-by-insertion in increments of h */
\par \hich\af1\dbch\af2\loch\f1         for (i = lb + h; i <= ub; i++) \{
\par \hich\af1\dbch\af2\loch\f1             }{\f1 \hich\af1\dbch\af2\loch\f1 t = a[i];
\par \hich\af1\dbch\af2\loch\f1             }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 for (j = i-h; j >= lb && compGT(a[j], t); j -= h)
\par \hich\af1\dbch\af2\loch\f1                 a[j+h] = a[j];
\par \hich\af1\dbch\af2\loch\f1             }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 a[j+h] = t;
\par \hich\af1\dbch\af2\loch\f1         }{\f1\lang2057\langfe1040\langnp2057 \}
\par 
\par \hich\af1\dbch\af2\loch\f1         /* compute next increment */
\par \hich\af1\dbch\af2\loch\f1         h /= 3;
\par \hich\af1\dbch\af2\loch\f1     \}
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 void fill(T *a, tblIndex lb, tblIndex ub) \{
\par \hich\af1\dbch\af2\loch\f1     tblIndex i;
\par \hich\af1\dbch\af2\loch\f1     srand(1);
\par \hich\af1\dbch\af2\loch\f1     for (i = lb; i <= ub; i++) a[i] = rand();
\par \}
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par \hich\af1\dbch\af2\loch\f1 int main(int argc, char *argv[]) \{
\par \hich\af1\dbch\af2\loch\f1     tblIndex maxnum, lb, ub;
\par \hich\af1\dbch\af2\loch\f1     T *a;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* command-line:
\par \hich\af1\dbch\af2\loch\f1      *
\par \hich\af1\dbch\af2\loch\f1      *   shl maxnum
\par \hich\af1\dbch\af2\loch\f1      *
\par \hich\af1\dbch\af2\loch\f1      *   shl 2000
\par \hich\af1\dbch\af2\loch\f1      *       sort 2000 records
\par \hich\af1\dbch\af2\loch\f1      */
\par 
\par \hich\af1\dbch\af2\loch\f1     maxnum = atoi(argv[1]);
\par \hich\af1\dbch\af2\loch\f1     lb = 0; ub = maxnum - 1;
\par \hich\af1\dbch\af2\loch\f1     i\hich\af1\dbch\af2\loch\f1 f ((a = malloc(maxnum * sizeof(T))) == 0) \{
\par \hich\af1\dbch\af2\loch\f1         fprintf (stderr, "insufficient memory (a)\\n");
\par \hich\af1\dbch\af2\loch\f1         exit(1);
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     fill(a, lb, ub);
\par \hich\af1\dbch\af2\loch\f1     shellSort(a, lb, ub);
\par 
\par \hich\af1\dbch\af2\loch\f1     }{\f1 \hich\af1\dbch\af2\loch\f1 return 0;
\par \}
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1040\langfe1040\cgrid\langnp1040\langfenp1040 {\f1\fs20 
\par }{\f1\fs20 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard\plain \s17\ql \li0\ri0\widctlpar\tx916\tx1832\tx2748\tx3664\tx4580\tx5496\tx6412\tx7328\tx8244\tx9160\tx10076\tx10992\tx11908\tx12824\tx13740\tx14656\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1040\langfe1040\loch\af2\hich\af2\dbch\af2\cgrid\langnp1040\langfenp1040 {\f1\lang2057\langfe1040\langnp2057 
\par 
\par 
\par 
\par 
\par }{\b\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 /* qsort() */
\par }{\f1\lang2057\langfe1040\langnp2057 
\par \hich\af1\dbch\af2\loch\f1 #include <stdio.h>
\par \hich\af1\dbch\af2\loch\f1 #in\hich\af1\dbch\af2\loch\f1 clude <stdlib.h>
\par \hich\af1\dbch\af2\loch\f1 #include <limits.h>
\par 
\par \hich\af1\dbch\af2\loch\f1 typedef int T;          /* type of item to be sorted */
\par 
\par \hich\af1\dbch\af2\loch\f1 #define MAXSTACK (sizeof(size_t) * CHAR_BIT)
\par 
\par \hich\af1\dbch\af2\loch\f1 static void exchange(void *a, void *b, size_t size) \{
\par \hich\af1\dbch\af2\loch\f1     size_t i;
\par 
\par \hich\af1\dbch\af2\loch\f1     /******************
\par \hich\af1\dbch\af2\loch\f1      *  exchange a,b  \hich\af1\dbch\af2\loch\f1 *
\par \hich\af1\dbch\af2\loch\f1      ******************/
\par 
\par \hich\af1\dbch\af2\loch\f1     for (i = sizeof(int); i <= size; i += sizeof(int)) \{
\par \hich\af1\dbch\af2\loch\f1         }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 int t = *((int *)a);
\par \hich\af1\dbch\af2\loch\f1         *(((int *)a)++) = *((int *)b);
\par \hich\af1\dbch\af2\loch\f1         *(((int *)b)++) = t;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \}
\par \hich\af1\dbch\af2\loch\f1     for (i = i - sizeof(int) + 1; i <= size; i++) \{
\par \hich\af1\dbch\af2\loch\f1         }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 char t =\hich\af1\dbch\af2\loch\f1  *((char *)a);
\par \hich\af1\dbch\af2\loch\f1         *(((char *)a)++) = *((char *)b);
\par \hich\af1\dbch\af2\loch\f1         *(((char *)b)++) = t;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \}
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 void qsort(void *base, size_t nmemb, size_t size,
\par \hich\af1\dbch\af2\loch\f1         int (*compar)(const void *, const void *)) \{
\par \hich\af1\dbch\af2\loch\f1     void *lbStack[MAXSTACK], *ubStack[MAXSTACK];
\par \hich\af1\dbch\af2\loch\f1     int s\hich\af1\dbch\af2\loch\f1 p;
\par \hich\af1\dbch\af2\loch\f1     unsigned int offset;
\par 
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 /********************
\par \hich\af1\dbch\af2\loch\f1      *  ANSI-C qsort()  *
\par \hich\af1\dbch\af2\loch\f1      }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 ********************/
\par 
\par \hich\af1\dbch\af2\loch\f1     lbStack[0] = (char *)base;
\par \hich\af1\dbch\af2\loch\f1     ubStack[0] = (char *)base + (nmemb-1)*size;
\par \hich\af1\dbch\af2\loch\f1     for (sp = 0; sp >= 0; sp--) \{
\par \hich\af1\dbch\af2\loch\f1         }{\f1\lang1031\langfe1040\langnp1031 \hich\af1\dbch\af2\loch\f1 char *lb, *ub, *m;
\par \hich\af1\dbch\af2\loch\f1        \hich\af1\dbch\af2\loch\f1  }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 char *P, *i, *j;
\par 
\par \hich\af1\dbch\af2\loch\f1         lb = lbStack[sp];
\par \hich\af1\dbch\af2\loch\f1         ub = ubStack[sp];
\par 
\par \hich\af1\dbch\af2\loch\f1         while (lb < ub) \{
\par 
\par \hich\af1\dbch\af2\loch\f1             /* select pivot and exchange with 1st element */
\par \hich\af1\dbch\af2\loch\f1             offset = (ub - lb) >> 1;
\par \hich\af1\dbch\af2\loch\f1             P = lb + offset - offset % size;
\par \hich\af1\dbch\af2\loch\f1             ex\hich\af1\dbch\af2\loch\f1 change (lb, P, size);
\par 
\par \hich\af1\dbch\af2\loch\f1             /* partition into two segments */
\par \hich\af1\dbch\af2\loch\f1             i = lb + size;
\par \hich\af1\dbch\af2\loch\f1             j = ub;
\par \hich\af1\dbch\af2\loch\f1             while (1) \{
\par \hich\af1\dbch\af2\loch\f1                 while (i < j && compar(lb, i) > 0) i += size;
\par \hich\af1\dbch\af2\loch\f1                 while (j >= i && compar(j, lb) > 0) j \hich\af1\dbch\af2\loch\f1 -= size;
\par \hich\af1\dbch\af2\loch\f1                 if (i >= j) break;
\par \hich\af1\dbch\af2\loch\f1                 exchange (i, j, size);
\par \hich\af1\dbch\af2\loch\f1                 j -= size;
\par \hich\af1\dbch\af2\loch\f1                 i += size;
\par \hich\af1\dbch\af2\loch\f1             \}
\par 
\par \hich\af1\dbch\af2\loch\f1             /* pivot belongs in A[j] */
\par \hich\af1\dbch\af2\loch\f1             exchange (lb, j, size);
\par \hich\af1\dbch\af2\loch\f1             m = j;
\par 
\par 
\par 
\par \hich\af1\dbch\af2\loch\f1       \hich\af1\dbch\af2\loch\f1       /* keep processing smallest segment, and stack largest */
\par \hich\af1\dbch\af2\loch\f1             if (m - lb <= ub - m) \{
\par \hich\af1\dbch\af2\loch\f1                 if (m + size < ub) \{
\par \hich\af1\dbch\af2\loch\f1                     lbStack[sp] = m + size;
\par \hich\af1\dbch\af2\loch\f1                     ubStack[sp++] = ub;
\par \hich\af1\dbch\af2\loch\f1                 \}
\par \hich\af1\dbch\af2\loch\f1                 u\hich\af1\dbch\af2\loch\f1 b = m - size;
\par \hich\af1\dbch\af2\loch\f1             \} else \{
\par \hich\af1\dbch\af2\loch\f1                 if (m - size > lb) \{
\par \hich\af1\dbch\af2\loch\f1                     lbStack[sp] = lb; 
\par \hich\af1\dbch\af2\loch\f1                     ubStack[sp++] = m - size;
\par \hich\af1\dbch\af2\loch\f1                 \}
\par \hich\af1\dbch\af2\loch\f1                 lb = m + size;
\par \hich\af1\dbch\af2\loch\f1             }{\f1\lang1036\langfe1040\langnp1036 \}
\par \hich\af1\dbch\af2\loch\f1         \}
\par \hich\af1\dbch\af2\loch\f1     \}
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 void fill(T *lb, \hich\af1\dbch\af2\loch\f1 T *ub) \{
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang1031\langfe1040\langnp1031 \hich\af1\dbch\af2\loch\f1 T *i;
\par \hich\af1\dbch\af2\loch\f1     srand(1);
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 for (i = lb; i <= ub; i++) *i = rand();
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 int Comp(const void *a, const void *b) \{ return *(T *)a - *(T *)b; \}
\par 
\par \hich\af1\dbch\af2\loch\f1 int main(int argc, char *argv[]) \{
\par \hich\af1\dbch\af2\loch\f1     int maxnum;
\par \hich\af1\dbch\af2\loch\f1     int *a, *lb, *ub;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* command-line:
\par \hich\af1\dbch\af2\loch\f1      }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 *
\par \hich\af1\dbch\af2\loch\f1     \hich\af1\dbch\af2\loch\f1  *   qsort maxnum
\par \hich\af1\dbch\af2\loch\f1      *
\par \hich\af1\dbch\af2\loch\f1      *   qsort 2000
\par \hich\af1\dbch\af2\loch\f1      *       sorts 2000 records
\par \hich\af1\dbch\af2\loch\f1      }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 *
\par \hich\af1\dbch\af2\loch\f1      */
\par 
\par \hich\af1\dbch\af2\loch\f1     maxnum = atoi(argv[1]);
\par \hich\af1\dbch\af2\loch\f1     if ((a = malloc(maxnum * sizeof(T))) == 0) \{
\par \hich\af1\dbch\af2\loch\f1         fprintf (stderr, "insufficient memory (a)\\n");
\par \hich\af1\dbch\af2\loch\f1         exit(1);
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     lb =\hich\af1\dbch\af2\loch\f1  a;  ub = a + maxnum - 1;
\par 
\par \hich\af1\dbch\af2\loch\f1     fill(lb, ub);
\par \hich\af1\dbch\af2\loch\f1     qsort(a, maxnum, sizeof(T), Comp);
\par \hich\af1\dbch\af2\loch\f1     return 0;
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1040\langfe1040\cgrid\langnp1040\langfenp1040 {\f1\fs20 \}
\par 
\par }\pard\plain \s17\ql \li0\ri0\widctlpar\tx916\tx1832\tx2748\tx3664\tx4580\tx5496\tx6412\tx7328\tx8244\tx9160\tx10076\tx10992\tx11908\tx12824\tx13740\tx14656\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1040\langfe1040\loch\af2\hich\af2\dbch\af2\cgrid\langnp1040\langfenp1040 {\b\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 /* hash table */
\par }{\f1\lang2057\langfe1040\langnp2057 
\par \hich\af1\dbch\af2\loch\f1 #include <stdio.h>
\par \hich\af1\dbch\af2\loch\f1 #include <stdlib.h>
\par 
\par \hich\af1\dbch\af2\loch\f1 /* implementation dependent declarations */
\par \hich\af1\dbch\af2\loch\f1 typedef int keyType;            /* type of key */
\par 
\par \hich\af1\dbch\af2\loch\f1 /* user data stored in hash table */
\par \hich\af1\dbch\af2\loch\f1 typedef struct \{
\par \hich\af1\dbch\af2\loch\f1     int stuff;                  /* optional related data */
\par \}\hich\af1\dbch\af2\loch\f1  recType;
\par 
\par \hich\af1\dbch\af2\loch\f1 typedef int hashIndexType;      /* index into hash table */
\par 
\par }{\f1 \hich\af1\dbch\af2\loch\f1 #define compEQ(a,b) (a == b)
\par 
\par 
\par }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 /* implementation independent declarat\hich\af1\dbch\af2\loch\f1 ions */
\par \hich\af1\dbch\af2\loch\f1 typedef enum \{
\par \hich\af1\dbch\af2\loch\f1     STATUS_OK,
\par \hich\af1\dbch\af2\loch\f1     STATUS_MEM_EXHAUSTED,
\par \hich\af1\dbch\af2\loch\f1     STATUS_KEY_NOT_FOUND
\par \}\hich\af1\dbch\af2\loch\f1  statusEnum;
\par 
\par \hich\af1\dbch\af2\loch\f1 typedef struct nodeTag \{
\par \hich\af1\dbch\af2\loch\f1     struct nodeTag *next;       /* next node */
\par \hich\af1\dbch\af2\loch\f1     keyType key;                /* key */
\par \hich\af1\dbch\af2\loch\f1     recType rec;                /* us\hich\af1\dbch\af2\loch\f1 er data */
\par \}\hich\af1\dbch\af2\loch\f1  nodeType;
\par 
\par \hich\af1\dbch\af2\loch\f1 nodeType **hashTable;
\par \hich\af1\dbch\af2\loch\f1 int hashTableSize;
\par 
\par \hich\af1\dbch\af2\loch\f1 hashIndexType hash(keyType key) \{
\par 
\par \hich\af1\dbch\af2\loch\f1    /***********************************
\par \hich\af1\dbch\af2\loch\f1     *  hash function applied to data  *
\par \hich\af1\dbch\af2\loch\f1     ***********************************/
\par 
\par \hich\af1\dbch\af2\loch\f1     return (key % hashTableSize);
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 statusEnum insert(keyType key, recType *rec) \{
\par \hich\af1\dbch\af2\loch\f1     nodeType *p, *p0;
\par \hich\af1\dbch\af2\loch\f1     hashIndexType bucket;
\par 
\par \hich\af1\dbch\af2\loch\f1    /************************************************
\par \hich\af1\dbch\af2\loch\f1     *  allocate node for data and insert in table  *
\par \hich\af1\dbch\af2\loch\f1     **********************************************\hich\af1\dbch\af2\loch\f1 **/
\par 
\par \hich\af1\dbch\af2\loch\f1     /* insert node at beginning of list */
\par \hich\af1\dbch\af2\loch\f1     bucket = hash(key);
\par \hich\af1\dbch\af2\loch\f1     if ((p = malloc(sizeof(nodeType))) == 0)
\par \hich\af1\dbch\af2\loch\f1         return STATUS_MEM_EXHAUSTED;
\par \hich\af1\dbch\af2\loch\f1     p0 = hashTable[bucket];
\par \hich\af1\dbch\af2\loch\f1     hashTable[bucket] = p;
\par \hich\af1\dbch\af2\loch\f1     p->next = p0;
\par \hich\af1\dbch\af2\loch\f1     p->key = key;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 p->rec \hich\af1\dbch\af2\loch\f1 = *rec;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 return STATUS_OK;
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 statusEnum delete(keyType key) \{
\par \hich\af1\dbch\af2\loch\f1     nodeType *p0, *p;
\par \hich\af1\dbch\af2\loch\f1     hashIndexType bucket;
\par 
\par \hich\af1\dbch\af2\loch\f1    /********************************************
\par \hich\af1\dbch\af2\loch\f1     *  delete node containing data from table  *
\par \hich\af1\dbch\af2\loch\f1     ***************************************\hich\af1\dbch\af2\loch\f1 *****/
\par 
\par \hich\af1\dbch\af2\loch\f1     /* find node */
\par \hich\af1\dbch\af2\loch\f1     p0 = 0;
\par \hich\af1\dbch\af2\loch\f1     bucket = hash(key);
\par \hich\af1\dbch\af2\loch\f1     p = hashTable[bucket];
\par \hich\af1\dbch\af2\loch\f1     while (p && !compEQ(p->key, key)) \{
\par \hich\af1\dbch\af2\loch\f1         p0 = p;
\par \hich\af1\dbch\af2\loch\f1         p = p->next;
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     if (!p) return STATUS_KEY_NOT_FOUND;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* p designates node to delete, remo\hich\af1\dbch\af2\loch\f1 ve it from list */
\par \hich\af1\dbch\af2\loch\f1     if (p0)
\par \hich\af1\dbch\af2\loch\f1         /* not first node, p0 points to previous node */
\par \hich\af1\dbch\af2\loch\f1         p0->next = p->next;
\par \hich\af1\dbch\af2\loch\f1     else
\par \hich\af1\dbch\af2\loch\f1         /* first node on chain */
\par \hich\af1\dbch\af2\loch\f1         hashTable[bucket] = p->next;
\par 
\par \hich\af1\dbch\af2\loch\f1     free (p);
\par \hich\af1\dbch\af2\loch\f1     return STATUS_OK;
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 statusEnum find(keyT\hich\af1\dbch\af2\loch\f1 ype key, recType *rec) \{
\par \hich\af1\dbch\af2\loch\f1     nodeType *p;
\par 
\par \hich\af1\dbch\af2\loch\f1    /*******************************
\par \hich\af1\dbch\af2\loch\f1     *  find node containing data  *
\par \hich\af1\dbch\af2\loch\f1     *******************************/
\par 
\par \hich\af1\dbch\af2\loch\f1     p = hashTable[hash(key)];
\par \hich\af1\dbch\af2\loch\f1     while (p && !compEQ(p->key, key)) p = p->next;
\par \hich\af1\dbch\af2\loch\f1     if (!p) return STA\hich\af1\dbch\af2\loch\f1 TUS_KEY_NOT_FOUND;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 *rec = p->rec;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 return STATUS_OK;
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 int main(int argc, char **argv) \{
\par \hich\af1\dbch\af2\loch\f1     int i, maxnum, random;
\par \hich\af1\dbch\af2\loch\f1     recType *rec;
\par \hich\af1\dbch\af2\loch\f1     keyType *key;
\par \hich\af1\dbch\af2\loch\f1     statusEnum err;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* command-line:
\par \hich\af1\dbch\af2\loch\f1      *
\par \hich\af1\dbch\af2\loch\f1      *   has maxnum hashTableSize [random]
\par \hich\af1\dbch\af2\loch\f1     \hich\af1\dbch\af2\loch\f1  *
\par \hich\af1\dbch\af2\loch\f1      *   has 2000 100
\par \hich\af1\dbch\af2\loch\f1      *       processes 2000 records, tablesize=100, sequential numbers
\par \hich\af1\dbch\af2\loch\f1      *   has 4000 200 r
\par \hich\af1\dbch\af2\loch\f1      *       processes 4000 records, tablesize=200, random numbers
\par \hich\af1\dbch\af2\loch\f1      }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 *
\par \hich\af1\dbch\af2\loch\f1      */
\par \hich\af1\dbch\af2\loch\f1     maxnum = atoi(argv[1]);
\par }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1     hashTableSize = atoi(a\hich\af1\dbch\af2\loch\f1 rgv[2]);
\par \hich\af1\dbch\af2\loch\f1     random = argc > 3;
\par 
\par \hich\af1\dbch\af2\loch\f1     if ((rec = malloc(maxnum * sizeof(recType))) == 0) \{
\par \hich\af1\dbch\af2\loch\f1         fprintf (stderr, "out of memory (rec)\\n");
\par \hich\af1\dbch\af2\loch\f1         exit(1);
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     if ((key = malloc(maxnum * sizeof(keyType))) == 0) \{
\par \hich\af1\dbch\af2\loch\f1         fprintf (stderr, "out of me\hich\af1\dbch\af2\loch\f1 mory (key)\\n");
\par \hich\af1\dbch\af2\loch\f1         exit(1);
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     if ((hashTable = calloc(hashTableSize, sizeof(nodeType *))) == 0) \{
\par \hich\af1\dbch\af2\loch\f1         fprintf (stderr, "out of memory (hashTable)\\n");
\par \hich\af1\dbch\af2\loch\f1         exit(1);
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     if (random) \{ /* random */
\par \hich\af1\dbch\af2\loch\f1         /* fill "key" with uniqu\hich\af1\dbch\af2\loch\f1 e random numbers */
\par \hich\af1\dbch\af2\loch\f1         for (i = 0; i < maxnum; i++) key[i] = rand();
\par \hich\af1\dbch\af2\loch\f1         printf ("ran ht, %d items, %d hashTable\\n", maxnum, hashTableSize);
\par \hich\af1\dbch\af2\loch\f1     \} else \{
\par \hich\af1\dbch\af2\loch\f1         for (i=0; i<maxnum; i++) key[i] = i;
\par \hich\af1\dbch\af2\loch\f1         printf ("seq ht, %d items, %d hashTable\\\hich\af1\dbch\af2\loch\f1 n", maxnum, hashTableSize);
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par 
\par \hich\af1\dbch\af2\loch\f1     for (i = 0; i < maxnum; i++) \{
\par \hich\af1\dbch\af2\loch\f1         err = insert(key[i], &rec[i]);
\par \hich\af1\dbch\af2\loch\f1         if (err) printf("pt1, i=%d\\n", i);
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     for (i = maxnum-1; i >= 0; i--) \{
\par \hich\af1\dbch\af2\loch\f1         err = find(key[i], &rec[i]);
\par \hich\af1\dbch\af2\loch\f1         if (err) prin\hich\af1\dbch\af2\loch\f1 tf("pt2, i=%d\\n", i);
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     for (i = maxnum-1; i >= 0; i--) \{
\par \hich\af1\dbch\af2\loch\f1         err = delete(key[i]);
\par \hich\af1\dbch\af2\loch\f1         if (err) printf("pt3, i=%d\\n", i);
\par \hich\af1\dbch\af2\loch\f1     }{\f1 \}
\par \hich\af1\dbch\af2\loch\f1     return 0;
\par \}
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1040\langfe1040\cgrid\langnp1040\langfenp1040 {\f1\fs20 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard\plain \s3\ql \li0\ri0\sb100\sa80\sbauto1\widctlpar\aspalpha\aspnum\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \b\f1\fs41\lang1040\langfe1040\cgrid\langnp1040\langfenp1040 {\fs20 
\par }\pard\plain \s17\ql \li0\ri0\widctlpar\tx916\tx1832\tx2748\tx3664\tx4580\tx5496\tx6412\tx7328\tx8244\tx9160\tx10076\tx10992\tx11908\tx12824\tx13740\tx14656\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1040\langfe1040\loch\af2\hich\af2\dbch\af2\cgrid\langnp1040\langfenp1040 {\b\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 /* binary search tree */
\par }{\f1\lang2057\langfe1040\langnp2057 
\par \hich\af1\dbch\af2\loch\f1 #include <stdio.h>
\par \hich\af1\dbch\af2\loch\f1 #include <stdlib.h>
\par 
\par }{\f1 \hich\af1\dbch\af2\loch\f1 #define compLT(a,b) (a < b)
\par \hich\af1\dbch\af2\loch\f1 #define compEQ(a,b) (a == b)
\par 
\par }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 /* implementation dependent declarations */
\par \hich\af1\dbch\af2\loch\f1 typedef enum \{
\par \hich\af1\dbch\af2\loch\f1     STATUS_OK,
\par \hich\af1\dbch\af2\loch\f1     STATUS_MEM_EXHAUSTED,
\par \hich\af1\dbch\af2\loch\f1     STATUS_DUPLICATE_KEY,
\par \hich\af1\dbch\af2\loch\f1     S\hich\af1\dbch\af2\loch\f1 TATUS_KEY_NOT_FOUND
\par \}\hich\af1\dbch\af2\loch\f1  statusEnum;
\par 
\par \hich\af1\dbch\af2\loch\f1 typedef int keyType;            /* type of key */
\par 
\par \hich\af1\dbch\af2\loch\f1 /* user data stored in tree */
\par \hich\af1\dbch\af2\loch\f1 typedef struct \{
\par \hich\af1\dbch\af2\loch\f1     int stuff;                  /* optional related data */
\par \}\hich\af1\dbch\af2\loch\f1  recType;
\par 
\par \hich\af1\dbch\af2\loch\f1 typedef struct nodeTag \{
\par \hich\af1\dbch\af2\loch\f1     struct nodeTag *left;\hich\af1\dbch\af2\loch\f1        /* left child */
\par \hich\af1\dbch\af2\loch\f1     struct nodeTag *right;      /* right child */
\par \hich\af1\dbch\af2\loch\f1     struct nodeTag *parent;     /* parent */
\par \hich\af1\dbch\af2\loch\f1     keyType key;                /* key used for searching */
\par \hich\af1\dbch\af2\loch\f1     recType rec;                /* user data */
\par \}\hich\af1\dbch\af2\loch\f1  nodeType;
\par \hich\af1\dbch\af2\loch\f1 nodeType *root =\hich\af1\dbch\af2\loch\f1  NULL;          /* root of binary tree */
\par 
\par \hich\af1\dbch\af2\loch\f1 statusEnum insert(keyType key, recType *rec) \{
\par \hich\af1\dbch\af2\loch\f1     nodeType *x, *current, *parent;
\par 
\par \hich\af1\dbch\af2\loch\f1    /***********************************************
\par \hich\af1\dbch\af2\loch\f1     *  allocate node for data and insert in tree  *
\par \hich\af1\dbch\af2\loch\f1     *********************\hich\af1\dbch\af2\loch\f1 **************************/
\par 
\par \hich\af1\dbch\af2\loch\f1     /* find future parent */
\par \hich\af1\dbch\af2\loch\f1     current = root;
\par \hich\af1\dbch\af2\loch\f1     parent = 0;
\par \hich\af1\dbch\af2\loch\f1     while (current) \{
\par \hich\af1\dbch\af2\loch\f1         if (compEQ(key, current->key)) 
\par \hich\af1\dbch\af2\loch\f1             return STATUS_DUPLICATE_KEY;
\par \hich\af1\dbch\af2\loch\f1         parent = current;
\par \hich\af1\dbch\af2\loch\f1         current = compLT(key, cur\hich\af1\dbch\af2\loch\f1 rent->key) ? 
\par \hich\af1\dbch\af2\loch\f1             current->left : current->right;
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     /* setup new node */
\par \hich\af1\dbch\af2\loch\f1     if ((x = malloc (sizeof(*x))) == 0) \{
\par \hich\af1\dbch\af2\loch\f1         return STATUS_MEM_EXHAUSTED;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang1036\langfe1040\langnp1036 \}
\par \hich\af1\dbch\af2\loch\f1     x->parent = parent;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 x->left = NULL;
\par \hich\af1\dbch\af2\loch\f1     x->right = NULL;
\par \hich\af1\dbch\af2\loch\f1     x->key = key\hich\af1\dbch\af2\loch\f1 ;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 x->rec = *rec;
\par 
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 /* insert x in tree */
\par \hich\af1\dbch\af2\loch\f1     if(parent)
\par \hich\af1\dbch\af2\loch\f1         if(compLT(x->key, parent->key))
\par \hich\af1\dbch\af2\loch\f1             parent->left = x;
\par \hich\af1\dbch\af2\loch\f1         else
\par \hich\af1\dbch\af2\loch\f1             parent->right = x;
\par \hich\af1\dbch\af2\loch\f1     else
\par \hich\af1\dbch\af2\loch\f1         root = x;
\par 
\par \hich\af1\dbch\af2\loch\f1     return STATUS_OK;
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 statusEnum delete(keyType\hich\af1\dbch\af2\loch\f1  key) \{
\par \hich\af1\dbch\af2\loch\f1     nodeType *x, *y, *z;
\par 
\par \hich\af1\dbch\af2\loch\f1    /***************************
\par \hich\af1\dbch\af2\loch\f1     *  delete node from tree  *
\par \hich\af1\dbch\af2\loch\f1     ***************************/
\par 
\par \hich\af1\dbch\af2\loch\f1     /* find node in tree */
\par \hich\af1\dbch\af2\loch\f1     z = root;
\par \hich\af1\dbch\af2\loch\f1     while(z != NULL) \{
\par \hich\af1\dbch\af2\loch\f1         if(compEQ(key, z->key)) 
\par \hich\af1\dbch\af2\loch\f1             break;
\par \hich\af1\dbch\af2\loch\f1        \hich\af1\dbch\af2\loch\f1  else
\par \hich\af1\dbch\af2\loch\f1             z = compLT(key, z->key) ? z->left : z->right;
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     if (!z) return STATUS_KEY_NOT_FOUND;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* find tree successor */
\par \hich\af1\dbch\af2\loch\f1     if (z->left == NULL || z->right == NULL)
\par \hich\af1\dbch\af2\loch\f1         }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 y = z;
\par \hich\af1\dbch\af2\loch\f1     else \{
\par \hich\af1\dbch\af2\loch\f1         y = z->right;
\par \hich\af1\dbch\af2\loch\f1         }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 while (y->lef\hich\af1\dbch\af2\loch\f1 t != }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 NULL) y = y->left;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \}
\par 
\par \hich\af1\dbch\af2\loch\f1     /* point x to a valid child of y, if it has one */
\par \hich\af1\dbch\af2\loch\f1     if (y->left != NULL)
\par \hich\af1\dbch\af2\loch\f1         x = y->left;
\par \hich\af1\dbch\af2\loch\f1     else
\par \hich\af1\dbch\af2\loch\f1         x = y->right;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* remove y from the parent chain */
\par \hich\af1\dbch\af2\loch\f1     if (x) x->parent = y->parent;
\par \hich\af1\dbch\af2\loch\f1     if (y->parent\hich\af1\dbch\af2\loch\f1 )
\par \hich\af1\dbch\af2\loch\f1         if (y == y->parent->left)
\par \hich\af1\dbch\af2\loch\f1             y->parent->left = x;
\par \hich\af1\dbch\af2\loch\f1         else
\par \hich\af1\dbch\af2\loch\f1             y->parent->right = x;
\par \hich\af1\dbch\af2\loch\f1     else
\par \hich\af1\dbch\af2\loch\f1         root = x;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* if z and y are not the same, copy y to z. */
\par \hich\af1\dbch\af2\loch\f1     if (y != z) \{
\par \hich\af1\dbch\af2\loch\f1         z->key = y->key;
\par \hich\af1\dbch\af2\loch\f1         }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 z->rec = \hich\af1\dbch\af2\loch\f1 y->rec;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \}
\par 
\par \hich\af1\dbch\af2\loch\f1     free (y);
\par \hich\af1\dbch\af2\loch\f1     return STATUS_OK;
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 statusEnum find(keyType key, recType *rec) \{
\par 
\par \hich\af1\dbch\af2\loch\f1    /*******************************
\par \hich\af1\dbch\af2\loch\f1     *  find node containing data  *
\par \hich\af1\dbch\af2\loch\f1     *******************************/
\par 
\par \hich\af1\dbch\af2\loch\f1     nodeType *current = root;
\par \hich\af1\dbch\af2\loch\f1     while(curren\hich\af1\dbch\af2\loch\f1 t != NULL) \{
\par \hich\af1\dbch\af2\loch\f1         if(compEQ(key, current->key)) \{
\par \hich\af1\dbch\af2\loch\f1             }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 *rec = current->rec;
\par \hich\af1\dbch\af2\loch\f1             }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 return STATUS_OK;
\par \hich\af1\dbch\af2\loch\f1         \} else \{
\par \hich\af1\dbch\af2\loch\f1             current = compLT(key, current->key) ? 
\par \hich\af1\dbch\af2\loch\f1                 current->left : current->right;
\par \hich\af1\dbch\af2\loch\f1         \}
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     retu\hich\af1\dbch\af2\loch\f1 rn STATUS_KEY_NOT_FOUND;
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 int main(int argc, char **argv) \{
\par \hich\af1\dbch\af2\loch\f1     int i, maxnum, random;
\par \hich\af1\dbch\af2\loch\f1     recType *rec;
\par \hich\af1\dbch\af2\loch\f1     keyType *key;
\par \hich\af1\dbch\af2\loch\f1     statusEnum status;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* command-line:
\par \hich\af1\dbch\af2\loch\f1      }{\f1\lang1031\langfe1040\langnp1031 \hich\af1\dbch\af2\loch\f1 *
\par \hich\af1\dbch\af2\loch\f1      *   bin maxnum random
\par \hich\af1\dbch\af2\loch\f1      *
\par \hich\af1\dbch\af2\loch\f1      *   bin 5000        // 5000 sequential
\par \hich\af1\dbch\af2\loch\f1  \hich\af1\dbch\af2\loch\f1     *   bin 2000 r      // 2000 random
\par \hich\af1\dbch\af2\loch\f1      }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 *
\par \hich\af1\dbch\af2\loch\f1      */
\par \hich\af1\dbch\af2\loch\f1     maxnum = atoi(argv[1]);
\par \hich\af1\dbch\af2\loch\f1     random = argc > 2;
\par 
\par \hich\af1\dbch\af2\loch\f1     if ((rec = malloc(maxnum * sizeof(recType))) == 0) \{
\par \hich\af1\dbch\af2\loch\f1         fprintf (stderr, "insufficient memory (rec)\\n");
\par \hich\af1\dbch\af2\loch\f1         exit(1);
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     if ((key \hich\af1\dbch\af2\loch\f1 = malloc(maxnum * sizeof(keyType))) == 0) \{
\par \hich\af1\dbch\af2\loch\f1         fprintf (stderr, "insufficient memory (key)\\n");
\par \hich\af1\dbch\af2\loch\f1         \hich\af1\dbch\af2\loch\f1 exit(1);
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     if (random) \{ /* random */
\par \hich\af1\dbch\af2\loch\f1         /* fill "key" with unique random numbers */
\par \hich\af1\dbch\af2\loch\f1         for (i = 0; i < maxnum; i++) key[i] = rand();
\par \hich\af1\dbch\af2\loch\f1         printf ("ran bt, %d items\\n", maxnum);
\par \hich\af1\dbch\af2\loch\f1     \} else \{
\par \hich\af1\dbch\af2\loch\f1         for (i=0; i<maxnum; i++) key[i] = i;
\par \hich\af1\dbch\af2\loch\f1        \hich\af1\dbch\af2\loch\f1  printf ("seq bt, %d items\\n", maxnum);
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par 
\par \hich\af1\dbch\af2\loch\f1     for (i = 0; i < maxnum; i++) \{
\par \hich\af1\dbch\af2\loch\f1         status = insert(key[i], &rec[i]);
\par \hich\af1\dbch\af2\loch\f1         if (status) printf("pt1, i=%d: %d\\n", i, status);
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     for (i = maxnum-1; i >= 0; i--) \{
\par \hich\af1\dbch\af2\loch\f1         status = find(key[i]\hich\af1\dbch\af2\loch\f1 , &rec[i]);
\par \hich\af1\dbch\af2\loch\f1         if (status) printf("pt2, i=%d: %d\\n", i, status);
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     for (i = maxnum-1; i >= 0; i--) \{
\par \hich\af1\dbch\af2\loch\f1         status = delete(key[i]);
\par \hich\af1\dbch\af2\loch\f1         if (status) printf("pt3, i=%d: %d\\n", i, status);
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     return 0;
\par \}
\par }{\f1\lang2057\langfe1040\langnp2057 \page }{\b\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 /* red-black tree */
\par }{\f1\lang2057\langfe1040\langnp2057 
\par \hich\af1\dbch\af2\loch\f1 #include <stdio.h>
\par \hich\af1\dbch\af2\loch\f1 #include <stdlib.h>
\par \hich\af1\dbch\af2\loch\f1 #include <string.h>
\par \hich\af1\dbch\af2\loch\f1 #include <stdarg.h>
\par 
\par 
\par \hich\af1\dbch\af2\loch\f1 /* implementation dependend declarations */
\par \hich\af1\dbch\af2\loch\f1 typedef enum \{
\par \hich\af1\dbch\af2\loch\f1     STATUS_OK,
\par \hich\af1\dbch\af2\loch\f1     STATUS_MEM_EXHAUSTED,
\par \hich\af1\dbch\af2\loch\f1     STATUS_DUPLICATE_KEY,
\par \hich\af1\dbch\af2\loch\f1     STATUS_KEY_NOT_FOUND
\par \}\hich\af1\dbch\af2\loch\f1  StatusEnum;
\par 
\par \hich\af1\dbch\af2\loch\f1 typedef\hich\af1\dbch\af2\loch\f1  int KeyType;            /* type of key */
\par 
\par \hich\af1\dbch\af2\loch\f1 /* user data stored in tree */
\par \hich\af1\dbch\af2\loch\f1 typedef struct \{
\par \hich\af1\dbch\af2\loch\f1     int stuff;                  /* optional related data */
\par \}\hich\af1\dbch\af2\loch\f1  RecType;
\par 
\par \hich\af1\dbch\af2\loch\f1 #define compLT(a,b) (a < b)
\par \hich\af1\dbch\af2\loch\f1 #define compEQ(a,b) (a == b)
\par 
\par \hich\af1\dbch\af2\loch\f1 /* implementation independent decl\hich\af1\dbch\af2\loch\f1 arations */
\par \hich\af1\dbch\af2\loch\f1 /* Red-Black tree description */
\par \hich\af1\dbch\af2\loch\f1 typedef enum \{ BLACK, RED \} nodeColor;
\par 
\par \hich\af1\dbch\af2\loch\f1 typedef struct NodeTag \{
\par \hich\af1\dbch\af2\loch\f1     struct NodeTag *left;       /* left child */
\par \hich\af1\dbch\af2\loch\f1     struct NodeTag *right;      /* right child */
\par \hich\af1\dbch\af2\loch\f1     struct NodeTag *parent;     /* parent */
\par \hich\af1\dbch\af2\loch\f1   \hich\af1\dbch\af2\loch\f1   nodeColor color;            /* node color (BLACK, RED) */
\par \hich\af1\dbch\af2\loch\f1     KeyType key;                /* key used for searching */
\par \hich\af1\dbch\af2\loch\f1     RecType rec;                /* user data */
\par \}\hich\af1\dbch\af2\loch\f1  NodeType;
\par 
\par \hich\af1\dbch\af2\loch\f1 typedef NodeType *iterator;
\par 
\par \hich\af1\dbch\af2\loch\f1 #define NIL &sentinel           /* all leafs \hich\af1\dbch\af2\loch\f1 are sentinels */
\par \hich\af1\dbch\af2\loch\f1 static NodeType sentinel = \{ &sentinel, &sentinel, 0, BLACK, 0\};
\par 
\par 
\par 
\par \hich\af1\dbch\af2\loch\f1 static NodeType *root = NIL;               /* root of Red-Black tree */
\par \hich\af1\dbch\af2\loch\f1 static void rotateLeft(NodeType *x) \{
\par 
\par \hich\af1\dbch\af2\loch\f1    /**************************
\par \hich\af1\dbch\af2\loch\f1     *  rotate node x to left \hich\af1\dbch\af2\loch\f1 *
\par \hich\af1\dbch\af2\loch\f1     **************************/
\par 
\par \hich\af1\dbch\af2\loch\f1     NodeType *y = x->right;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* establish x->right link */
\par \hich\af1\dbch\af2\loch\f1     x->right = y->left;
\par \hich\af1\dbch\af2\loch\f1     if (y->left != }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 NIL) y->left->parent = x;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* establish y->parent link */
\par \hich\af1\dbch\af2\loch\f1     if (y != NIL) y->parent = x->parent;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 if (x->p\hich\af1\dbch\af2\loch\f1 arent) \{
\par \hich\af1\dbch\af2\loch\f1         if (x == x->parent->left)
\par \hich\af1\dbch\af2\loch\f1             }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 x->parent->left = y;
\par \hich\af1\dbch\af2\loch\f1         }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 else
\par \hich\af1\dbch\af2\loch\f1             x->parent->right = y;
\par \hich\af1\dbch\af2\loch\f1     \} else \{
\par \hich\af1\dbch\af2\loch\f1         root = y;
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     /* link x and y */
\par \hich\af1\dbch\af2\loch\f1     y->left = x;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 if (x != NIL) x->parent = y;
\par }{\f1\lang2057\langfe1040\langnp2057 \}
\par 
\par \hich\af1\dbch\af2\loch\f1 static void rotateR\hich\af1\dbch\af2\loch\f1 ight(NodeType *x) \{
\par 
\par \hich\af1\dbch\af2\loch\f1    /****************************
\par \hich\af1\dbch\af2\loch\f1     *  rotate node x to right  *
\par \hich\af1\dbch\af2\loch\f1     ****************************/
\par 
\par \hich\af1\dbch\af2\loch\f1     NodeType *y = x->left;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* establish x->left link */
\par \hich\af1\dbch\af2\loch\f1     x->left = y->right;
\par \hich\af1\dbch\af2\loch\f1     if (y->right != }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 NIL) y->right->parent = x;
\par 
\par \hich\af1\dbch\af2\loch\f1  \hich\af1\dbch\af2\loch\f1    /* establish y->parent link */
\par \hich\af1\dbch\af2\loch\f1     if (y != NIL) y->parent = x->parent;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 if (x->parent) \{
\par \hich\af1\dbch\af2\loch\f1         if (x == x->parent->right)
\par \hich\af1\dbch\af2\loch\f1             }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 x->parent->right = y;
\par \hich\af1\dbch\af2\loch\f1         }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 else
\par \hich\af1\dbch\af2\loch\f1             x->parent->left = y;
\par \hich\af1\dbch\af2\loch\f1     \} else \{
\par \hich\af1\dbch\af2\loch\f1         root = y;
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     /* \hich\af1\dbch\af2\loch\f1 link x and y */
\par \hich\af1\dbch\af2\loch\f1     y->right = x;
\par \hich\af1\dbch\af2\loch\f1     if (x != }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 NIL) x->parent = y;
\par }{\f1\lang2057\langfe1040\langnp2057 \}
\par 
\par 
\par \hich\af1\dbch\af2\loch\f1 static void insertFixup(NodeType *x) \{
\par 
\par \hich\af1\dbch\af2\loch\f1    /*************************************
\par \hich\af1\dbch\af2\loch\f1     *  maintain Red-Black tree balance  *
\par \hich\af1\dbch\af2\loch\f1     *  after inserting node x           *
\par \hich\af1\dbch\af2\loch\f1     **********\hich\af1\dbch\af2\loch\f1 ***************************/
\par 
\par \hich\af1\dbch\af2\loch\f1     /* check Red-Black properties */
\par \hich\af1\dbch\af2\loch\f1     while (x != root && x->parent->color == RED) \{
\par \hich\af1\dbch\af2\loch\f1         /* we have a violation */
\par \hich\af1\dbch\af2\loch\f1         if (x->parent == x->parent->parent->left) \{
\par \hich\af1\dbch\af2\loch\f1             NodeType *y = x->parent->parent->right;
\par \hich\af1\dbch\af2\loch\f1             if (y->color == RED) \{
\par 
\par \hich\af1\dbch\af2\loch\f1                 /* uncle is RED */
\par \hich\af1\dbch\af2\loch\f1                 x->parent->color = BLACK;
\par \hich\af1\dbch\af2\loch\f1                 y->color = BLACK;
\par \hich\af1\dbch\af2\loch\f1                 x->parent->parent->color = RED;
\par \hich\af1\dbch\af2\loch\f1                 }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 x = x->parent->parent;
\par \hich\af1\dbch\af2\loch\f1             }{\f1\lang2057\langfe1040\langnp2057 \}\hich\af1\dbch\af2\loch\f1  else \{
\par 
\par \hich\af1\dbch\af2\loch\f1                 /* uncle is BLACK */
\par \hich\af1\dbch\af2\loch\f1                 if (x == x->parent->right) \{
\par \hich\af1\dbch\af2\loch\f1                     /* make x a left child */
\par \hich\af1\dbch\af2\loch\f1                     }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 x = x->parent;
\par \hich\af1\dbch\af2\loch\f1                     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 rotateLeft(x);
\par \hich\af1\dbch\af2\loch\f1                 \}
\par 
\par \hich\af1\dbch\af2\loch\f1                 /* recolor and rotate *\hich\af1\dbch\af2\loch\f1 /
\par \hich\af1\dbch\af2\loch\f1                 x->parent->color = BLACK;
\par \hich\af1\dbch\af2\loch\f1                 x->parent->parent->color = RED;
\par \hich\af1\dbch\af2\loch\f1                 rotateRight(x->parent->parent);
\par \hich\af1\dbch\af2\loch\f1             \}
\par \hich\af1\dbch\af2\loch\f1         \} else \{
\par 
\par \hich\af1\dbch\af2\loch\f1             /* mirror image of above code */
\par \hich\af1\dbch\af2\loch\f1             }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 NodeType *y = x->parent->pa\hich\af1\dbch\af2\loch\f1 rent->left;
\par \hich\af1\dbch\af2\loch\f1             }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 if (y->color == RED) \{
\par 
\par \hich\af1\dbch\af2\loch\f1                 /* uncle is RED */
\par \hich\af1\dbch\af2\loch\f1                 x->parent->color = BLACK;
\par \hich\af1\dbch\af2\loch\f1                 y->color = BLACK;
\par \hich\af1\dbch\af2\loch\f1                 x->parent->parent->color = RED;
\par \hich\af1\dbch\af2\loch\f1                 }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 x = x->parent->parent;
\par \hich\af1\dbch\af2\loch\f1           \hich\af1\dbch\af2\loch\f1   }{\f1\lang2057\langfe1040\langnp2057 \}\hich\af1\dbch\af2\loch\f1  else \{
\par 
\par \hich\af1\dbch\af2\loch\f1                 /* uncle is BLACK */
\par \hich\af1\dbch\af2\loch\f1                 if (x == x->parent->left) \{
\par \hich\af1\dbch\af2\loch\f1                     }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 x = x->parent;
\par \hich\af1\dbch\af2\loch\f1                     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 rotateRight(x);
\par \hich\af1\dbch\af2\loch\f1                 \}
\par \hich\af1\dbch\af2\loch\f1                 x->parent->color = BLACK;
\par \hich\af1\dbch\af2\loch\f1                 x->parent->paren\hich\af1\dbch\af2\loch\f1 t->color = RED;
\par \hich\af1\dbch\af2\loch\f1                 rotateLeft(x->parent->parent);
\par \hich\af1\dbch\af2\loch\f1             \}
\par \hich\af1\dbch\af2\loch\f1         \}
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     root->color = BLACK;
\par \}
\par 
\par 
\par \hich\af1\dbch\af2\loch\f1 StatusEnum insert(KeyType key, RecType *rec) \{
\par \hich\af1\dbch\af2\loch\f1     NodeType *current, *parent, *x;
\par 
\par \hich\af1\dbch\af2\loch\f1    /********************************************\hich\af1\dbch\af2\loch\f1 ***
\par \hich\af1\dbch\af2\loch\f1     *  allocate node for data and insert in tree  *
\par \hich\af1\dbch\af2\loch\f1     ***********************************************/
\par 
\par \hich\af1\dbch\af2\loch\f1     /* find future parent */
\par \hich\af1\dbch\af2\loch\f1     current = root;
\par \hich\af1\dbch\af2\loch\f1     parent = 0;
\par \hich\af1\dbch\af2\loch\f1     while (current != NIL) \{
\par \hich\af1\dbch\af2\loch\f1         if (compEQ(key, current->key)) 
\par \hich\af1\dbch\af2\loch\f1             \hich\af1\dbch\af2\loch\f1 return STATUS_DUPLICATE_KEY;
\par \hich\af1\dbch\af2\loch\f1         parent = current;
\par \hich\af1\dbch\af2\loch\f1         current = compLT(key, current->key) ?
\par \hich\af1\dbch\af2\loch\f1             current->left : current->right;
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     /* setup new node */
\par \hich\af1\dbch\af2\loch\f1     if ((x = malloc (sizeof(*x))) == 0)
\par \hich\af1\dbch\af2\loch\f1         return STATUS_MEM_EXHAUSTED;
\par \hich\af1\dbch\af2\loch\f1   \hich\af1\dbch\af2\loch\f1   }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 x->parent = parent;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 x->left = NIL;
\par \hich\af1\dbch\af2\loch\f1     x->right = NIL;
\par \hich\af1\dbch\af2\loch\f1     x->color = RED;
\par \hich\af1\dbch\af2\loch\f1     x->key = key;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 x->rec = *rec;
\par 
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 /* insert node in tree */
\par \hich\af1\dbch\af2\loch\f1     if(parent) \{
\par \hich\af1\dbch\af2\loch\f1         if(compLT(key, parent->key))
\par \hich\af1\dbch\af2\loch\f1             parent->left = x;
\par \hich\af1\dbch\af2\loch\f1         else
\par \hich\af1\dbch\af2\loch\f1           \hich\af1\dbch\af2\loch\f1   parent->right = x;
\par \hich\af1\dbch\af2\loch\f1     \} else \{
\par \hich\af1\dbch\af2\loch\f1         root = x;
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     insertFixup(x);
\par 
\par \hich\af1\dbch\af2\loch\f1     return STATUS_OK;
\par \}
\par 
\par 
\par \hich\af1\dbch\af2\loch\f1 void deleteFixup(NodeType *x) \{
\par 
\par \hich\af1\dbch\af2\loch\f1    /*************************************
\par \hich\af1\dbch\af2\loch\f1     *  maintain Red-Black tree balance  *
\par \hich\af1\dbch\af2\loch\f1     *  after d\hich\af1\dbch\af2\loch\f1 eleting node x            *
\par \hich\af1\dbch\af2\loch\f1     *************************************/
\par 
\par \hich\af1\dbch\af2\loch\f1     while (x != root && x->color == BLACK) \{
\par \hich\af1\dbch\af2\loch\f1         if (x == x->parent->left) \{
\par \hich\af1\dbch\af2\loch\f1             NodeType *w = x->parent->right;
\par \hich\af1\dbch\af2\loch\f1             if (w->color == RED) \{
\par \hich\af1\dbch\af2\loch\f1                 w->color\hich\af1\dbch\af2\loch\f1  = BLACK;
\par \hich\af1\dbch\af2\loch\f1                 x->parent->color = RED;
\par \hich\af1\dbch\af2\loch\f1                 rotateLeft (x->parent);
\par \hich\af1\dbch\af2\loch\f1                 w = x->parent->right;
\par \hich\af1\dbch\af2\loch\f1             \}
\par \hich\af1\dbch\af2\loch\f1             if (w->left->color == BLACK && w->right->color == BLACK) \{
\par \hich\af1\dbch\af2\loch\f1                 w->color = RED;
\par \hich\af1\dbch\af2\loch\f1            \hich\af1\dbch\af2\loch\f1      }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 x = x->parent;
\par \hich\af1\dbch\af2\loch\f1             }{\f1\lang2057\langfe1040\langnp2057 \}\hich\af1\dbch\af2\loch\f1  else \{
\par \hich\af1\dbch\af2\loch\f1                 if (w->right->color == BLACK) \{
\par \hich\af1\dbch\af2\loch\f1                     w->left->color = BLACK;
\par \hich\af1\dbch\af2\loch\f1                     w->color = RED;
\par \hich\af1\dbch\af2\loch\f1                     rotateRight (w);
\par \hich\af1\dbch\af2\loch\f1                     w = x->parent->right;
\par \hich\af1\dbch\af2\loch\f1         \hich\af1\dbch\af2\loch\f1         \}
\par \hich\af1\dbch\af2\loch\f1                 w->color = x->parent->color;
\par \hich\af1\dbch\af2\loch\f1                 x->parent->color = BLACK;
\par \hich\af1\dbch\af2\loch\f1                 w->right->color = BLACK;
\par \hich\af1\dbch\af2\loch\f1                 rotateLeft (x->parent);
\par \hich\af1\dbch\af2\loch\f1                 x = root;
\par \hich\af1\dbch\af2\loch\f1             \}
\par \hich\af1\dbch\af2\loch\f1         \} else \{
\par \hich\af1\dbch\af2\loch\f1             NodeType \hich\af1\dbch\af2\loch\f1 *w = x->parent->left;
\par \hich\af1\dbch\af2\loch\f1             if (w->color == RED) \{
\par \hich\af1\dbch\af2\loch\f1                 w->color = BLACK;
\par \hich\af1\dbch\af2\loch\f1                 x->parent->color = RED;
\par \hich\af1\dbch\af2\loch\f1                 rotateRight (x->parent);
\par \hich\af1\dbch\af2\loch\f1                 w = x->parent->left;
\par \hich\af1\dbch\af2\loch\f1             \}
\par \hich\af1\dbch\af2\loch\f1             if (w->right->color =\hich\af1\dbch\af2\loch\f1 = BLACK && w->left->color == BLACK) \{
\par \hich\af1\dbch\af2\loch\f1                 w->color = RED;
\par \hich\af1\dbch\af2\loch\f1                 }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 x = x->parent;
\par \hich\af1\dbch\af2\loch\f1             }{\f1\lang2057\langfe1040\langnp2057 \}\hich\af1\dbch\af2\loch\f1  else \{
\par \hich\af1\dbch\af2\loch\f1                 if (w->left->color == BLACK) \{
\par \hich\af1\dbch\af2\loch\f1                     w->right->color = BLACK;
\par \hich\af1\dbch\af2\loch\f1                     w->color = RED;
\par \hich\af1\dbch\af2\loch\f1       \hich\af1\dbch\af2\loch\f1               rotateLeft (w);
\par \hich\af1\dbch\af2\loch\f1                     w = x->parent->left;
\par \hich\af1\dbch\af2\loch\f1                 \}
\par \hich\af1\dbch\af2\loch\f1                 w->color = x->parent->color;
\par \hich\af1\dbch\af2\loch\f1                 x->parent->color = BLACK;
\par \hich\af1\dbch\af2\loch\f1                 w->left->color = BLACK;
\par \hich\af1\dbch\af2\loch\f1                 rotateRight (x->parent);
\par \hich\af1\dbch\af2\loch\f1                 x = root;
\par \hich\af1\dbch\af2\loch\f1             \}
\par \hich\af1\dbch\af2\loch\f1         \}
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     x->color = BLACK;
\par }{\f1\lang1031\langfe1040\langnp1031 \}
\par 
\par 
\par \hich\af1\dbch\af2\loch\f1 StatusEnum erase(iterator z) \{
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 NodeType *x, *y;
\par 
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 if (z->left == NIL || z->right == NIL) \{
\par \hich\af1\dbch\af2\loch\f1         /* y has a NIL node as a child */
\par \hich\af1\dbch\af2\loch\f1         }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 y = z;
\par \hich\af1\dbch\af2\loch\f1     \} else \{
\par \hich\af1\dbch\af2\loch\f1     \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 /* find tree successor with a NIL node as a child */
\par \hich\af1\dbch\af2\loch\f1         }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 y = z->right;
\par \hich\af1\dbch\af2\loch\f1         }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 while (y->left != }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 NIL) y = y->left;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \}
\par 
\par \hich\af1\dbch\af2\loch\f1     /* x is y's only child */
\par \hich\af1\dbch\af2\loch\f1     if (y->left != NIL)
\par \hich\af1\dbch\af2\loch\f1         x = y->left;
\par \hich\af1\dbch\af2\loch\f1     else
\par \hich\af1\dbch\af2\loch\f1         x = y->right;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* remove y fro\hich\af1\dbch\af2\loch\f1 m the parent chain */
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 x->parent = y->parent;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 if (y->parent)
\par \hich\af1\dbch\af2\loch\f1         if (y == y->parent->left)
\par \hich\af1\dbch\af2\loch\f1             y->parent->left = x;
\par \hich\af1\dbch\af2\loch\f1         else
\par \hich\af1\dbch\af2\loch\f1             y->parent->right = x;
\par \hich\af1\dbch\af2\loch\f1     else
\par \hich\af1\dbch\af2\loch\f1         root = x;
\par 
\par \hich\af1\dbch\af2\loch\f1     if (y != z) \{
\par \hich\af1\dbch\af2\loch\f1         z->key = y->key;
\par \hich\af1\dbch\af2\loch\f1    \hich\af1\dbch\af2\loch\f1      }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 z->rec = y->rec;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \}
\par 
\par 
\par \hich\af1\dbch\af2\loch\f1     if (y->color == BLACK)
\par \hich\af1\dbch\af2\loch\f1         deleteFixup (x);
\par 
\par \hich\af1\dbch\af2\loch\f1     free (y);
\par 
\par \hich\af1\dbch\af2\loch\f1     return STATUS_OK;
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 StatusEnum eraseKey(KeyType key) \{
\par \hich\af1\dbch\af2\loch\f1     NodeType *z;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* find node in tree */
\par \hich\af1\dbch\af2\loch\f1     z = root;
\par \hich\af1\dbch\af2\loch\f1     while(z != NIL) \{
\par \hich\af1\dbch\af2\loch\f1         if(compE\hich\af1\dbch\af2\loch\f1 Q(key, z->key)) 
\par \hich\af1\dbch\af2\loch\f1             break;
\par \hich\af1\dbch\af2\loch\f1         else
\par \hich\af1\dbch\af2\loch\f1             z = compLT(key, z->key) ? z->left : z->right;
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     if (z == NIL) return STATUS_KEY_NOT_FOUND;
\par \hich\af1\dbch\af2\loch\f1     return erase(z);
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 iterator next(iterator i) \{
\par \hich\af1\dbch\af2\loch\f1     if (i->right != NIL) \{
\par \hich\af1\dbch\af2\loch\f1         /* go rig\hich\af1\dbch\af2\loch\f1 ht 1, then left to the end */
\par \hich\af1\dbch\af2\loch\f1         for (i = i->right; i->left != NIL; i = i->left);
\par \hich\af1\dbch\af2\loch\f1     \} else \{
\par \hich\af1\dbch\af2\loch\f1         /* while you're the right child, chain up parent link */
\par \hich\af1\dbch\af2\loch\f1         iterator p = i->parent;
\par \hich\af1\dbch\af2\loch\f1         while (p && i == p->right) \{
\par \hich\af1\dbch\af2\loch\f1             i = p;
\par \hich\af1\dbch\af2\loch\f1    \hich\af1\dbch\af2\loch\f1          p = p->parent;
\par \hich\af1\dbch\af2\loch\f1         \}
\par 
\par \hich\af1\dbch\af2\loch\f1         /* return the "inorder" node */
\par \hich\af1\dbch\af2\loch\f1         i = p;
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     return i;
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 iterator begin() \{
\par \hich\af1\dbch\af2\loch\f1    /* return pointer to first value */
\par \hich\af1\dbch\af2\loch\f1    iterator i;
\par \hich\af1\dbch\af2\loch\f1    for (i = root; i->left != NIL; i = i->left);
\par \hich\af1\dbch\af2\loch\f1    return i;
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 iterat\hich\af1\dbch\af2\loch\f1 or end() \{
\par \hich\af1\dbch\af2\loch\f1    /* return pointer to one past last value */
\par \hich\af1\dbch\af2\loch\f1    return NULL;
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 RecType value(iterator i) \{
\par \hich\af1\dbch\af2\loch\f1     /* return record associated with iterator */
\par \hich\af1\dbch\af2\loch\f1     return i->rec;
\par \}
\par 
\par 
\par \hich\af1\dbch\af2\loch\f1 StatusEnum find(KeyType key, iterator *iter) \{
\par \hich\af1\dbch\af2\loch\f1     NodeType *current;
\par \hich\af1\dbch\af2\loch\f1     curre\hich\af1\dbch\af2\loch\f1 nt = root;
\par \hich\af1\dbch\af2\loch\f1     while(current != NIL) \{
\par \hich\af1\dbch\af2\loch\f1         if(compEQ(key, current->key)) \{
\par \hich\af1\dbch\af2\loch\f1             *iter = current;
\par \hich\af1\dbch\af2\loch\f1             return STATUS_OK;
\par \hich\af1\dbch\af2\loch\f1         \} else \{
\par \hich\af1\dbch\af2\loch\f1             current = compLT (key, current->key) ?
\par \hich\af1\dbch\af2\loch\f1                 current->left : current->right;
\par \hich\af1\dbch\af2\loch\f1   \hich\af1\dbch\af2\loch\f1       \}
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     return STATUS_KEY_NOT_FOUND;
\par \}
\par 
\par 
\par \hich\af1\dbch\af2\loch\f1 int main(int argc, char **argv) \{
\par \hich\af1\dbch\af2\loch\f1     int maxnum, ct, n;
\par \hich\af1\dbch\af2\loch\f1     RecType rec;
\par \hich\af1\dbch\af2\loch\f1     KeyType key;
\par \hich\af1\dbch\af2\loch\f1     StatusEnum status;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* command-line:
\par \hich\af1\dbch\af2\loch\f1      }{\f1\lang1031\langfe1040\langnp1031 \hich\af1\dbch\af2\loch\f1 *
\par \hich\af1\dbch\af2\loch\f1      *   rbt maxnum
\par \hich\af1\dbch\af2\loch\f1      *
\par \hich\af1\dbch\af2\loch\f1      *   rbt 2000
\par \hich\af1\dbch\af2\loch\f1      }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 *       process 2000 records
\par \hich\af1\dbch\af2\loch\f1      *
\par \hich\af1\dbch\af2\loch\f1      */
\par 
\par \hich\af1\dbch\af2\loch\f1     iterator iter;
\par 
\par \hich\af1\dbch\af2\loch\f1     \hich\af1\dbch\af2\loch\f1 maxnum = atoi(argv[1]);
\par 
\par \hich\af1\dbch\af2\loch\f1     printf("maxnum = %d\\n",\hich\af1\dbch\af2\loch\f1  maxnum);
\par \hich\af1\dbch\af2\loch\f1     \hich\af1\dbch\af2\loch\f1 for (ct = maxnum; ct; ct--) \{
\par \hich\af1\dbch\af2\loch\f1         key = rand() % 90 + 1;
\par \hich\af1\dbch\af2\loch\f1         if ((status = find(key, &iter)) == STATUS_OK) \{
\par \hich\af1\dbch\af2\loch\f1             rec = value(iter);
\par \hich\af1\dbch\af2\loch\f1             if (rec.stuff != key) printf("fail rec\\n");
\par \hich\af1\dbch\af2\loch\f1             status = erase(iter);
\par \hich\af1\dbch\af2\loch\f1             if (st\hich\af1\dbch\af2\loch\f1 atus) printf("fail: status = %d\\n", status);
\par \hich\af1\dbch\af2\loch\f1         \} else \{
\par \hich\af1\dbch\af2\loch\f1             rec.stuff = key;
\par \hich\af1\dbch\af2\loch\f1             status = insert(key, &rec);
\par \hich\af1\dbch\af2\loch\f1             if (status) printf("fail: status = %d\\n", status);
\par \hich\af1\dbch\af2\loch\f1         \}
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     /* output nodes in order */
\par \hich\af1\dbch\af2\loch\f1     \{
\par \hich\af1\dbch\af2\loch\f1        \hich\af1\dbch\af2\loch\f1  iterator i;
\par 
\par \hich\af1\dbch\af2\loch\f1         for (i = begin(); i != end(); i = next(i)) \{
\par \hich\af1\dbch\af2\loch\f1             RecType rec;
\par \hich\af1\dbch\af2\loch\f1             rec = value(i);
\par \hich\af1\dbch\af2\loch\f1             printf("%d\\n", rec.stuff);
\par \hich\af1\dbch\af2\loch\f1         \}
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     \hich\af1\dbch\af2\loch\f1 return 0;
\par \}
\par }{\f1\lang2057\langfe1040\langnp2057 \page }{\b\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 /* skip list */
\par }{\f1\lang2057\langfe1040\langnp2057 
\par \hich\af1\dbch\af2\loch\f1 #include <stdio.h>
\par \hich\af1\dbch\af2\loch\f1 #include <stdlib.h>
\par 
\par \hich\af1\dbch\af2\loch\f1 /* implementation dependent declarations */
\par \hich\af1\dbch\af2\loch\f1 typedef enum \{
\par \hich\af1\dbch\af2\loch\f1     STATUS_OK,
\par \hich\af1\dbch\af2\loch\f1     STATUS_MEM_EXHAUSTED,
\par \hich\af1\dbch\af2\loch\f1     STATUS_DUPLICATE_KEY,
\par \hich\af1\dbch\af2\loch\f1     STATUS_KEY_NOT_FOUND
\par \}\hich\af1\dbch\af2\loch\f1  statusEnum;
\par 
\par \hich\af1\dbch\af2\loch\f1 typedef int keyType;            /* type of key *\hich\af1\dbch\af2\loch\f1 /
\par 
\par \hich\af1\dbch\af2\loch\f1 /* user data stored in tree */
\par \hich\af1\dbch\af2\loch\f1 typedef struct \{
\par \hich\af1\dbch\af2\loch\f1     int stuff;                  /* optional related data */
\par \}\hich\af1\dbch\af2\loch\f1  recType;
\par 
\par \hich\af1\dbch\af2\loch\f1 #define compLT(a,b) (a < b)
\par \hich\af1\dbch\af2\loch\f1 #define compEQ(a,b) (a == b)
\par 
\par \hich\af1\dbch\af2\loch\f1 /* levels range from (0 .. MAXLEVEL) */
\par \hich\af1\dbch\af2\loch\f1 #define MAXLEVEL 15
\par 
\par \hich\af1\dbch\af2\loch\f1 typedef struct\hich\af1\dbch\af2\loch\f1  nodeTag \{
\par \hich\af1\dbch\af2\loch\f1     keyType key;                /* key used for searching */
\par \hich\af1\dbch\af2\loch\f1     recType rec;                /* user data */
\par \hich\af1\dbch\af2\loch\f1     struct nodeTag *forward[1]; /* skip list forward pointer */
\par \}\hich\af1\dbch\af2\loch\f1  nodeType;
\par 
\par \hich\af1\dbch\af2\loch\f1 /* implementation independent declarations */
\par \hich\af1\dbch\af2\loch\f1 typedef struc\hich\af1\dbch\af2\loch\f1 t \{
\par \hich\af1\dbch\af2\loch\f1     nodeType *hdr;              /* list Header */
\par \hich\af1\dbch\af2\loch\f1     int listLevel;              /* current level of list */
\par \}\hich\af1\dbch\af2\loch\f1  SkipList;
\par 
\par \hich\af1\dbch\af2\loch\f1 SkipList list;                  /* skip list information */
\par 
\par \hich\af1\dbch\af2\loch\f1 #define NIL list.hdr
\par 
\par 
\par 
\par \hich\af1\dbch\af2\loch\f1 statusEnum insert(keyType key, recType *rec)\hich\af1\dbch\af2\loch\f1  \{
\par \hich\af1\dbch\af2\loch\f1     int i, newLevel;
\par \hich\af1\dbch\af2\loch\f1     nodeType *update[MAXLEVEL+1];
\par \hich\af1\dbch\af2\loch\f1     nodeType *x;
\par 
\par \hich\af1\dbch\af2\loch\f1    /***********************************************
\par \hich\af1\dbch\af2\loch\f1     *  allocate node for data and insert in list  *
\par \hich\af1\dbch\af2\loch\f1     ***********************************************/
\par 
\par \hich\af1\dbch\af2\loch\f1     /* find where key \hich\af1\dbch\af2\loch\f1 belongs */
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 x = list.hdr;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 for (i = list.listLevel; i >= 0; i--) \{
\par \hich\af1\dbch\af2\loch\f1         while (x->forward[i] != NIL 
\par \hich\af1\dbch\af2\loch\f1           && compLT(x->forward[i]->key, key))
\par \hich\af1\dbch\af2\loch\f1             x = x->forward[i];
\par \hich\af1\dbch\af2\loch\f1         }{\f1 \hich\af1\dbch\af2\loch\f1 update[i] = x;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \}
\par \hich\af1\dbch\af2\loch\f1     x = x->forward[0];
\par \hich\af1\dbch\af2\loch\f1     if (x != NIL \hich\af1\dbch\af2\loch\f1 && compEQ(x->key, key)) 
\par \hich\af1\dbch\af2\loch\f1         return STATUS_DUPLICATE_KEY;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* determine level */
\par \hich\af1\dbch\af2\loch\f1     for (
\par \hich\af1\dbch\af2\loch\f1       newLevel = 0; 
\par \hich\af1\dbch\af2\loch\f1       rand() < RAND_MAX/2 && newLevel < MAXLEVEL; 
\par \hich\af1\dbch\af2\loch\f1       newLevel++);
\par 
\par \hich\af1\dbch\af2\loch\f1     if (newLevel > list.listLevel) \{
\par \hich\af1\dbch\af2\loch\f1         for (i = list.listLe\hich\af1\dbch\af2\loch\f1 vel + 1; i <= newLevel; i++)
\par \hich\af1\dbch\af2\loch\f1             }{\f1 \hich\af1\dbch\af2\loch\f1 update[i] = NIL;
\par \hich\af1\dbch\af2\loch\f1         }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 list.listLevel = newLevel;
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     /* make new node */
\par \hich\af1\dbch\af2\loch\f1     if ((x = malloc(sizeof(nodeType) + newLevel*sizeof(nodeType *))) == 0)
\par \hich\af1\dbch\af2\loch\f1         return STATUS_MEM_EXHAUSTED;
\par \hich\af1\dbch\af2\loch\f1     x->key = key;
\par \hich\af1\dbch\af2\loch\f1   \hich\af1\dbch\af2\loch\f1   }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 x->rec = *rec;
\par 
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 /* update forward links */
\par \hich\af1\dbch\af2\loch\f1     for (i = 0; i <= newLevel; i++) \{
\par \hich\af1\dbch\af2\loch\f1         x->forward[i] = update[i]->forward[i];
\par \hich\af1\dbch\af2\loch\f1         update[i]->forward[i] = x;
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     return STATUS_OK;
\par \}
\par 
\par 
\par \hich\af1\dbch\af2\loch\f1 statusEnum delete(keyType key) \{
\par \hich\af1\dbch\af2\loch\f1     int\hich\af1\dbch\af2\loch\f1  i;
\par \hich\af1\dbch\af2\loch\f1     nodeType *update[MAXLEVEL+1], *x;
\par 
\par \hich\af1\dbch\af2\loch\f1    /*******************************************
\par \hich\af1\dbch\af2\loch\f1     *  delete node containing data from list  *
\par \hich\af1\dbch\af2\loch\f1     *******************************************/
\par 
\par \hich\af1\dbch\af2\loch\f1     /* find where data belongs */
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 x = list.hdr;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 for (i = li\hich\af1\dbch\af2\loch\f1 st.listLevel; i >= 0; i--) \{
\par \hich\af1\dbch\af2\loch\f1         while (x->forward[i] != NIL 
\par \hich\af1\dbch\af2\loch\f1           && compLT(x->forward[i]->key, key))
\par \hich\af1\dbch\af2\loch\f1             x = x->forward[i];
\par \hich\af1\dbch\af2\loch\f1         }{\f1 \hich\af1\dbch\af2\loch\f1 update[i] = x;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \}
\par \hich\af1\dbch\af2\loch\f1     x = x->forward[0];
\par \hich\af1\dbch\af2\loch\f1     if (x == NIL || !compEQ(x->key, key)) return STATUS_KEY_N\hich\af1\dbch\af2\loch\f1 OT_FOUND;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* adjust forward pointers */
\par \hich\af1\dbch\af2\loch\f1     for (i = 0; i <= list.listLevel; i++) \{
\par \hich\af1\dbch\af2\loch\f1         if (update[i]->forward[i] != x) break;
\par \hich\af1\dbch\af2\loch\f1         update[i]->forward[i] = x->forward[i];
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     free (x);
\par 
\par \hich\af1\dbch\af2\loch\f1     /* adjust header level */
\par \hich\af1\dbch\af2\loch\f1     while ((list.list\hich\af1\dbch\af2\loch\f1 Level > 0)
\par \hich\af1\dbch\af2\loch\f1     && (list.hdr->forward[list.listLevel] == NIL))
\par \hich\af1\dbch\af2\loch\f1         list.listLevel--;
\par 
\par \hich\af1\dbch\af2\loch\f1     return STATUS_OK;
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 statusEnum find(keyType key, recType *rec) \{
\par \hich\af1\dbch\af2\loch\f1     int i;
\par \hich\af1\dbch\af2\loch\f1     nodeType *x = list.hdr;
\par 
\par \hich\af1\dbch\af2\loch\f1    /*******************************
\par \hich\af1\dbch\af2\loch\f1     *  find node cont\hich\af1\dbch\af2\loch\f1 aining data  *
\par \hich\af1\dbch\af2\loch\f1     *******************************/
\par 
\par \hich\af1\dbch\af2\loch\f1     for (i = list.listLevel; i >= 0; i--) \{
\par \hich\af1\dbch\af2\loch\f1         while (x->forward[i] != NIL 
\par \hich\af1\dbch\af2\loch\f1           && compLT(x->forward[i]->key, key))
\par \hich\af1\dbch\af2\loch\f1             x = x->forward[i];
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     x = x->forward[0];
\par \hich\af1\dbch\af2\loch\f1     if (x != NIL\hich\af1\dbch\af2\loch\f1  && compEQ(x->key, key)) \{
\par \hich\af1\dbch\af2\loch\f1         }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 *rec = x->rec;
\par \hich\af1\dbch\af2\loch\f1         }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 return STATUS_OK;
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     return STATUS_KEY_NOT_FOUND;
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 void initList() \{
\par \hich\af1\dbch\af2\loch\f1     int i;
\par 
\par \hich\af1\dbch\af2\loch\f1    /**************************
\par \hich\af1\dbch\af2\loch\f1     *  initialize skip list  *
\par \hich\af1\dbch\af2\loch\f1     **************************/
\par 
\par \hich\af1\dbch\af2\loch\f1     if\hich\af1\dbch\af2\loch\f1  ((list.hdr = malloc(
\par \hich\af1\dbch\af2\loch\f1             sizeof(nodeType) + MAXLEVEL*sizeof(nodeType *))) == 0) \{
\par \hich\af1\dbch\af2\loch\f1         printf ("insufficient memory (initList)\\n");
\par \hich\af1\dbch\af2\loch\f1         exit(1);
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     for (i = 0; i <= MAXLEVEL; i++)
\par \hich\af1\dbch\af2\loch\f1         list.hdr->forward[i] = NIL;
\par \hich\af1\dbch\af2\loch\f1     list.listLeve\hich\af1\dbch\af2\loch\f1 l = 0;
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 int main(int argc, char **argv) \{
\par \hich\af1\dbch\af2\loch\f1     int i, maxnum, random;
\par \hich\af1\dbch\af2\loch\f1     recType *rec;
\par \hich\af1\dbch\af2\loch\f1     keyType *key;
\par \hich\af1\dbch\af2\loch\f1     statusEnum status;
\par 
\par 
\par \hich\af1\dbch\af2\loch\f1     /* command-line:
\par \hich\af1\dbch\af2\loch\f1      }{\f1\lang1031\langfe1040\langnp1031 \hich\af1\dbch\af2\loch\f1 *
\par \hich\af1\dbch\af2\loch\f1      *   skl maxnum [random]
\par \hich\af1\dbch\af2\loch\f1      }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 *
\par \hich\af1\dbch\af2\loch\f1      *   skl 2000
\par \hich\af1\dbch\af2\loch\f1      *       process 2000 sequential recor\hich\af1\dbch\af2\loch\f1 ds
\par \hich\af1\dbch\af2\loch\f1      *   skl 4000 r
\par \hich\af1\dbch\af2\loch\f1      *       process 4000 random records
\par \hich\af1\dbch\af2\loch\f1      }{\f1\lang1031\langfe1040\langnp1031 \hich\af1\dbch\af2\loch\f1 *
\par \hich\af1\dbch\af2\loch\f1      */
\par 
\par \hich\af1\dbch\af2\loch\f1     maxnum = atoi(argv[1]);
\par \hich\af1\dbch\af2\loch\f1     random = argc > 2;
\par 
\par \hich\af1\dbch\af2\loch\f1     initList();
\par 
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 if ((rec = malloc(maxnum * sizeof(recType))) == 0) \{
\par \hich\af1\dbch\af2\loch\f1         fprintf (stderr, "insufficient memory (rec\hich\af1\dbch\af2\loch\f1 )\\n");
\par \hich\af1\dbch\af2\loch\f1         exit(1);
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     if ((key = malloc(maxnum * sizeof(keyType))) == 0) \{
\par \hich\af1\dbch\af2\loch\f1         fprintf (stderr, "insufficient memory (key)\\n");
\par \hich\af1\dbch\af2\loch\f1         \hich\af1\dbch\af2\loch\f1 exit(1);
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     if (random) \{
\par \hich\af1\dbch\af2\loch\f1         /* fill "a" with unique random numbers */
\par \hich\af1\dbch\af2\loch\f1         for (i = 0; i < maxnum; i++) key[i] = rand();
\par \hich\af1\dbch\af2\loch\f1         printf ("ran, %d items\\n", maxnum);
\par \hich\af1\dbch\af2\loch\f1     \} else \{
\par \hich\af1\dbch\af2\loch\f1         for (i = 0; i < maxnum; i++) key[i] = i;
\par \hich\af1\dbch\af2\loch\f1         printf ("seq, %d ite\hich\af1\dbch\af2\loch\f1 ms\\n", maxnum);
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     for (i = 0; i < maxnum; i++) \{
\par \hich\af1\dbch\af2\loch\f1         status = insert(key[i], &rec[i]);
\par \hich\af1\dbch\af2\loch\f1         if (status) printf("pt1: error = %d\\n", status);
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     for (i = maxnum-1; i >= 0; i--) \{
\par \hich\af1\dbch\af2\loch\f1         status = find(key[i], &rec[i]);
\par \hich\af1\dbch\af2\loch\f1         if (st\hich\af1\dbch\af2\loch\f1 atus) printf("pt2: error = %d\\n", status);
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     for (i = maxnum-1; i >= 0; i--) \{
\par \hich\af1\dbch\af2\loch\f1         status = delete(key[i]);
\par \hich\af1\dbch\af2\loch\f1         if (status) printf("pt3: error = %d\\n", status);
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     return 0;
\par \}
\par }{\f1\lang2057\langfe1040\langnp2057 \page }{\b\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 /* external sort */
\par }{\f1\lang2057\langfe1040\langnp2057 
\par \hich\af1\dbch\af2\loch\f1 #include <stdio.h>
\par \hich\af1\dbch\af2\loch\f1 #include <stdlib.h>
\par \hich\af1\dbch\af2\loch\f1 #include <string.h>
\par 
\par \hich\af1\dbch\af2\loch\f1 /****************************
\par \hich\af1\dbch\af2\loch\f1  * implementation dependent *
\par \hich\af1\dbch\af2\loch\f1  ****************************/
\par 
\par \hich\af1\dbch\af2\loch\f1 /* template for workfiles (8.3 format) */
\par \hich\af1\dbch\af2\loch\f1 #define FNAME "_sort%03d.dat"
\par \hich\af1\dbch\af2\loch\f1 #define LNAME 13
\par 
\par \hich\af1\dbch\af2\loch\f1 /* compariso\hich\af1\dbch\af2\loch\f1 n operators */
\par \hich\af1\dbch\af2\loch\f1 #define compLT(x,y) (x < y)
\par \hich\af1\dbch\af2\loch\f1 #define compGT(x,y) (x > y)
\par 
\par \hich\af1\dbch\af2\loch\f1 /* define the record to be sorted here */
\par \hich\af1\dbch\af2\loch\f1 #define LRECL 100
\par \hich\af1\dbch\af2\loch\f1 typedef int keyType;
\par \hich\af1\dbch\af2\loch\f1 typedef struct recTypeTag \{
\par \hich\af1\dbch\af2\loch\f1     keyType key;                                /* sort key for record */
\par \hich\af1\dbch\af2\loch\f1  \hich\af1\dbch\af2\loch\f1    #if LRECL
\par \hich\af1\dbch\af2\loch\f1         char data[LRECL-sizeof(keyType)];       /* other fields */
\par \hich\af1\dbch\af2\loch\f1     #endif
\par \}\hich\af1\dbch\af2\loch\f1  recType;
\par 
\par \hich\af1\dbch\af2\loch\f1 /******************************
\par \hich\af1\dbch\af2\loch\f1  * implementation independent *
\par \hich\af1\dbch\af2\loch\f1  ******************************/
\par 
\par \hich\af1\dbch\af2\loch\f1 typedef enum \{false, true\} bool;
\par 
\par \hich\af1\dbch\af2\loch\f1 typedef struct tmpFil\hich\af1\dbch\af2\loch\f1 eTag \{
\par \hich\af1\dbch\af2\loch\f1     FILE *fp;                   /* file pointer */
\par \hich\af1\dbch\af2\loch\f1     char name[LNAME];           /* filename */
\par \hich\af1\dbch\af2\loch\f1     recType rec;                /* last record read */
\par \hich\af1\dbch\af2\loch\f1     int dummy;                  /* number of dummy runs */
\par \hich\af1\dbch\af2\loch\f1     bool eof;                   /* en\hich\af1\dbch\af2\loch\f1 d-of-file flag */
\par \hich\af1\dbch\af2\loch\f1     bool eor;                   /* end-of-run flag */
\par \hich\af1\dbch\af2\loch\f1     bool valid;                 /* true if rec is valid */
\par \hich\af1\dbch\af2\loch\f1     int fib;                    /* ideal fibonacci number */
\par \}\hich\af1\dbch\af2\loch\f1  tmpFileType;
\par 
\par \hich\af1\dbch\af2\loch\f1 static tmpFileType **file;      /* array of file\hich\af1\dbch\af2\loch\f1  info for tmp files */
\par \hich\af1\dbch\af2\loch\f1 static int nTmpFiles;           /* number of tmp files */
\par \hich\af1\dbch\af2\loch\f1 static char *ifName;            /* input filename */
\par \hich\af1\dbch\af2\loch\f1 static char *ofName;            /* output filename */
\par 
\par \hich\af1\dbch\af2\loch\f1 static int level;               /* level of runs */
\par \hich\af1\dbch\af2\loch\f1 static int nNod\hich\af1\dbch\af2\loch\f1 es;              /* number of nodes for selection tree */
\par 
\par \hich\af1\dbch\af2\loch\f1 void deleteTmpFiles(void) \{
\par \hich\af1\dbch\af2\loch\f1     int i;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* delete merge files and free resources */
\par \hich\af1\dbch\af2\loch\f1     if (file) \{
\par \hich\af1\dbch\af2\loch\f1         for (i = 0; i < nTmpFiles; i++) \{
\par \hich\af1\dbch\af2\loch\f1             if (file[i]) \{
\par \hich\af1\dbch\af2\loch\f1                 if (file\hich\af1\dbch\af2\loch\f1 [i]->fp) fclose(file[i]->fp);
\par \hich\af1\dbch\af2\loch\f1                 if (*file[i]->name) remove(file[i]->name);
\par \hich\af1\dbch\af2\loch\f1                 free (file[i]);
\par \hich\af1\dbch\af2\loch\f1             \}
\par \hich\af1\dbch\af2\loch\f1         \}
\par \hich\af1\dbch\af2\loch\f1         free (file);
\par \hich\af1\dbch\af2\loch\f1     \}
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 void termTmpFiles(int rc) \{
\par 
\par \hich\af1\dbch\af2\loch\f1     /* cleanup files */
\par \hich\af1\dbch\af2\loch\f1     remove(ofName);
\par \hich\af1\dbch\af2\loch\f1     if (\hich\af1\dbch\af2\loch\f1 rc == 0) \{
\par \hich\af1\dbch\af2\loch\f1         int fileT;
\par 
\par \hich\af1\dbch\af2\loch\f1         }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 /* file[T] contains results */
\par \hich\af1\dbch\af2\loch\f1         }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 fileT = nTmpFiles - 1;
\par \hich\af1\dbch\af2\loch\f1         fclose(file[fileT]->fp); file[fileT]->fp = NULL;
\par \hich\af1\dbch\af2\loch\f1         if (rename(file[fileT]->name, ofName)) \{
\par \hich\af1\dbch\af2\loch\f1             }{\f1 \hich\af1\dbch\af2\loch\f1 perror("io1");
\par \hich\af1\dbch\af2\loch\f1             deleteTmpF\hich\af1\dbch\af2\loch\f1 iles();
\par \hich\af1\dbch\af2\loch\f1             }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 exit(1);
\par \hich\af1\dbch\af2\loch\f1         \}
\par \hich\af1\dbch\af2\loch\f1         *file[fileT]->name = 0;
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     deleteTmpFiles();
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 void cleanExit(int rc) \{
\par 
\par \hich\af1\dbch\af2\loch\f1     /* cleanup tmp files and exit */
\par \hich\af1\dbch\af2\loch\f1     termTmpFiles(rc);
\par \hich\af1\dbch\af2\loch\f1     exit(rc);
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 void *safeMalloc(size_t size) \{
\par \hich\af1\dbch\af2\loch\f1     void *p;
\par 
\par \hich\af1\dbch\af2\loch\f1     /*\hich\af1\dbch\af2\loch\f1  safely allocate memory and initialize to zero */
\par \hich\af1\dbch\af2\loch\f1     if ((p = calloc(1, size)) == NULL) \{
\par \hich\af1\dbch\af2\loch\f1         printf("error: malloc failed, size = %d\\n", size);
\par \hich\af1\dbch\af2\loch\f1         cleanExit(1);
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     return p;
\par \}
\par \hich\af1\dbch\af2\loch\f1 void initTmpFiles(void) \{
\par \hich\af1\dbch\af2\loch\f1     int i;
\par \hich\af1\dbch\af2\loch\f1     tmpFileType *fileInfo\hich\af1\dbch\af2\loch\f1 ;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* initialize merge files */
\par \hich\af1\dbch\af2\loch\f1     if (nTmpFiles < 3) nTmpFiles = 3;
\par \hich\af1\dbch\af2\loch\f1     file = safeMalloc(nTmpFiles * sizeof(tmpFileType*));
\par \hich\af1\dbch\af2\loch\f1     fileInfo = safeMalloc(nTmpFiles * sizeof(tmpFileType));
\par \hich\af1\dbch\af2\loch\f1     for (i = 0; i < nTmpFiles; i++) \{
\par \hich\af1\dbch\af2\loch\f1         }{\f1 \hich\af1\dbch\af2\loch\f1 file[i] = fileInfo \hich\af1\dbch\af2\loch\f1 + i;
\par \hich\af1\dbch\af2\loch\f1         }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 sprintf(file[i]->name, FNAME, i);
\par \hich\af1\dbch\af2\loch\f1         if ((file[i]->fp = fopen(file[i]->name, "w+b")) == NULL) \{
\par \hich\af1\dbch\af2\loch\f1             perror("io2");
\par \hich\af1\dbch\af2\loch\f1             cleanExit(1);
\par \hich\af1\dbch\af2\loch\f1         \}
\par \hich\af1\dbch\af2\loch\f1     \}
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 recType *readRec(void) \{
\par 
\par \hich\af1\dbch\af2\loch\f1     typedef struct iNodeTag \{   /* internal \hich\af1\dbch\af2\loch\f1 node */
\par \hich\af1\dbch\af2\loch\f1         struct iNodeTag *parent;/* parent of internal node */
\par \hich\af1\dbch\af2\loch\f1         struct eNodeTag *loser; /* external loser */
\par \hich\af1\dbch\af2\loch\f1     \} iNodeType;
\par 
\par \hich\af1\dbch\af2\loch\f1     typedef struct eNodeTag \{   /* external node */
\par \hich\af1\dbch\af2\loch\f1         struct iNodeTag *parent;/* parent of external node */
\par \hich\af1\dbch\af2\loch\f1  \hich\af1\dbch\af2\loch\f1        recType rec;            /* input record */
\par \hich\af1\dbch\af2\loch\f1         int run;                /* run number */
\par \hich\af1\dbch\af2\loch\f1         bool valid;             /* input record is valid */
\par \hich\af1\dbch\af2\loch\f1     \} eNodeType;
\par 
\par \hich\af1\dbch\af2\loch\f1     typedef struct nodeTag \{
\par \hich\af1\dbch\af2\loch\f1         }{\f1 \hich\af1\dbch\af2\loch\f1 iNodeType i;            /* internal node *\hich\af1\dbch\af2\loch\f1 /
\par \hich\af1\dbch\af2\loch\f1         }{\f1\lang1031\langfe1040\langnp1031 \hich\af1\dbch\af2\loch\f1 eNodeType e;            /* external node */
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \}\hich\af1\dbch\af2\loch\f1  nodeType;
\par 
\par \hich\af1\dbch\af2\loch\f1     static nodeType *node;      /* array of selection tree nodes */
\par \hich\af1\dbch\af2\loch\f1     static eNodeType *win;      /* new winner */
\par \hich\af1\dbch\af2\loch\f1     static FILE *ifp;           /* input file */
\par \hich\af1\dbch\af2\loch\f1     static bool eof\hich\af1\dbch\af2\loch\f1 ;            /* true if end-of-file, input */
\par \hich\af1\dbch\af2\loch\f1     static int maxRun;          /* maximum run number */
\par \hich\af1\dbch\af2\loch\f1     static int curRun;          /* current run number */
\par \hich\af1\dbch\af2\loch\f1     iNodeType *p;               /* pointer to internal nodes */
\par \hich\af1\dbch\af2\loch\f1     static bool lastKeyValid;   \hich\af1\dbch\af2\loch\f1 /* true if lastKey is valid */
\par \hich\af1\dbch\af2\loch\f1     static keyType lastKey;     /* last key written */
\par 
\par \hich\af1\dbch\af2\loch\f1     /* read next record using replacement selection */
\par 
\par \hich\af1\dbch\af2\loch\f1     /* check for first call */
\par \hich\af1\dbch\af2\loch\f1     if (node == NULL) \{
\par \hich\af1\dbch\af2\loch\f1         int i;
\par 
\par \hich\af1\dbch\af2\loch\f1         if (nNodes < 2) nNodes = 2;
\par \hich\af1\dbch\af2\loch\f1       \hich\af1\dbch\af2\loch\f1   node = safeMalloc(nNodes * sizeof(nodeType));
\par \hich\af1\dbch\af2\loch\f1         for (i = 0; i < nNodes; i++) \{
\par \hich\af1\dbch\af2\loch\f1             }{\f1 \hich\af1\dbch\af2\loch\f1 node[i].i.loser = &node[i].e;
\par \hich\af1\dbch\af2\loch\f1             node[i].i.parent = &node[i/2].i;
\par \hich\af1\dbch\af2\loch\f1             node[i].e.parent = &node[(nNodes + i)/2].i;
\par \hich\af1\dbch\af2\loch\f1             node[i].e.run \hich\af1\dbch\af2\loch\f1 = 0;
\par \hich\af1\dbch\af2\loch\f1             node[i].e.valid = false;
\par \hich\af1\dbch\af2\loch\f1         \}
\par \hich\af1\dbch\af2\loch\f1         win = &node[0].e;
\par \hich\af1\dbch\af2\loch\f1         }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 lastKeyValid = false;
\par 
\par \hich\af1\dbch\af2\loch\f1         if ((ifp = fopen(ifName, "rb")) == NULL) \{
\par \hich\af1\dbch\af2\loch\f1             printf("error: file %s, unable to open\\n", ifName);
\par \hich\af1\dbch\af2\loch\f1             cleanExit(1);
\par \hich\af1\dbch\af2\loch\f1       \hich\af1\dbch\af2\loch\f1   \}
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     while (1) \{
\par 
\par \hich\af1\dbch\af2\loch\f1         /* replace previous winner with new record */
\par \hich\af1\dbch\af2\loch\f1         if (!eof) \{
\par \hich\af1\dbch\af2\loch\f1             if (fread(&win->rec, sizeof(recType), 1, ifp) == 1) \{
\par \hich\af1\dbch\af2\loch\f1                 if ((!lastKeyValid || compLT(win->rec.key, lastKey))
\par \hich\af1\dbch\af2\loch\f1                 && \hich\af1\dbch\af2\loch\f1 (++win->run > maxRun))
\par \hich\af1\dbch\af2\loch\f1                     maxRun = win->run;
\par \hich\af1\dbch\af2\loch\f1                 win->valid = true;
\par \hich\af1\dbch\af2\loch\f1             \} else if (feof(ifp)) \{
\par \hich\af1\dbch\af2\loch\f1                 fclose(ifp);
\par \hich\af1\dbch\af2\loch\f1                 eof = true;
\par \hich\af1\dbch\af2\loch\f1                 win->valid = false;
\par \hich\af1\dbch\af2\loch\f1                 win->run = max\hich\af1\dbch\af2\loch\f1 Run + 1;
\par \hich\af1\dbch\af2\loch\f1             \} else \{
\par \hich\af1\dbch\af2\loch\f1                 perror("io4");
\par \hich\af1\dbch\af2\loch\f1                 cleanExit(1);
\par \hich\af1\dbch\af2\loch\f1             \} 
\par \hich\af1\dbch\af2\loch\f1         \} else \{
\par \hich\af1\dbch\af2\loch\f1             win->valid = false;
\par \hich\af1\dbch\af2\loch\f1             win->run = maxRun + 1;
\par \hich\af1\dbch\af2\loch\f1         \}
\par 
\par \hich\af1\dbch\af2\loch\f1         /* adjust loser and winner pointers */
\par \hich\af1\dbch\af2\loch\f1         \hich\af1\dbch\af2\loch\f1 p = win->parent;
\par \hich\af1\dbch\af2\loch\f1         do \{
\par \hich\af1\dbch\af2\loch\f1             bool swap;
\par \hich\af1\dbch\af2\loch\f1             swap = false;
\par \hich\af1\dbch\af2\loch\f1             if (p->loser->run < win->run) \{
\par \hich\af1\dbch\af2\loch\f1                 swap = true;
\par \hich\af1\dbch\af2\loch\f1             \} else if (p->loser->run == win->run) \{
\par \hich\af1\dbch\af2\loch\f1                 if (p->loser->valid && win->valid) \{
\par \hich\af1\dbch\af2\loch\f1                     if (compLT(p->loser->rec.key, win->rec.key))
\par \hich\af1\dbch\af2\loch\f1                         swap = true;
\par \hich\af1\dbch\af2\loch\f1                 \} else \{
\par \hich\af1\dbch\af2\loch\f1                     swap = true;
\par \hich\af1\dbch\af2\loch\f1                 \}
\par \hich\af1\dbch\af2\loch\f1             \}
\par \hich\af1\dbch\af2\loch\f1             if (swap) \{
\par \hich\af1\dbch\af2\loch\f1                 /* p should be winner *\hich\af1\dbch\af2\loch\f1 /
\par \hich\af1\dbch\af2\loch\f1                 }{\f1\lang1031\langfe1040\langnp1031 \hich\af1\dbch\af2\loch\f1 eNodeType *t;
\par 
\par \hich\af1\dbch\af2\loch\f1                 t = p->loser;
\par \hich\af1\dbch\af2\loch\f1                 p->loser = win;
\par \hich\af1\dbch\af2\loch\f1                 }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 win = t;
\par \hich\af1\dbch\af2\loch\f1             \}
\par \hich\af1\dbch\af2\loch\f1             p = p->parent;
\par \hich\af1\dbch\af2\loch\f1         }{\f1\lang2057\langfe1040\langnp2057 \}\hich\af1\dbch\af2\loch\f1  while (p != &node[0].i);
\par 
\par \hich\af1\dbch\af2\loch\f1         /* end of run? */
\par \hich\af1\dbch\af2\loch\f1         if (win->run != curRun) \{
\par \hich\af1\dbch\af2\loch\f1             /* win->run = curRun + 1 */
\par \hich\af1\dbch\af2\loch\f1             if (win->run > maxRun) \{
\par \hich\af1\dbch\af2\loch\f1                 /* end of output */
\par \hich\af1\dbch\af2\loch\f1                 free(node);
\par \hich\af1\dbch\af2\loch\f1                 return NULL;
\par \hich\af1\dbch\af2\loch\f1             \}
\par \hich\af1\dbch\af2\loch\f1             curRun = win->run;
\par \hich\af1\dbch\af2\loch\f1         \}
\par 
\par \hich\af1\dbch\af2\loch\f1         /* output top of tree\hich\af1\dbch\af2\loch\f1  */
\par \hich\af1\dbch\af2\loch\f1         if (win->run) \{
\par \hich\af1\dbch\af2\loch\f1             lastKey = win->rec.key;
\par \hich\af1\dbch\af2\loch\f1             lastKeyValid = true;
\par \hich\af1\dbch\af2\loch\f1             return &win->rec;
\par \hich\af1\dbch\af2\loch\f1         \}
\par \hich\af1\dbch\af2\loch\f1     \}
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 void makeRuns(void) \{
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang1031\langfe1040\langnp1031 \hich\af1\dbch\af2\loch\f1 recType *win;       /* winner */
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 int fileT;          /* last file */
\par \hich\af1\dbch\af2\loch\f1     int fil\hich\af1\dbch\af2\loch\f1 eP;          /* next to last file */
\par \hich\af1\dbch\af2\loch\f1     int j;              /* selects file[j] */
\par 
\par 
\par \hich\af1\dbch\af2\loch\f1     /* Make initial runs using replacement selection.
\par \hich\af1\dbch\af2\loch\f1      * Runs are written using a Fibonacci distintbution.
\par \hich\af1\dbch\af2\loch\f1      */
\par 
\par \hich\af1\dbch\af2\loch\f1     /* initialize file structures */
\par \hich\af1\dbch\af2\loch\f1     fileT = nT\hich\af1\dbch\af2\loch\f1 mpFiles - 1;
\par \hich\af1\dbch\af2\loch\f1     fileP = fileT - 1;
\par \hich\af1\dbch\af2\loch\f1     for (j = 0; j < fileT; j++) \{
\par \hich\af1\dbch\af2\loch\f1         file[j]->fib = 1;
\par \hich\af1\dbch\af2\loch\f1         file[j]->dummy = 1;
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     file[fileT]->fib = 0;
\par \hich\af1\dbch\af2\loch\f1     file[fileT]->dummy = 0;
\par 
\par \hich\af1\dbch\af2\loch\f1     level = 1;
\par \hich\af1\dbch\af2\loch\f1     j = 0;
\par 
\par 
\par \hich\af1\dbch\af2\loch\f1     win = readRec();
\par \hich\af1\dbch\af2\loch\f1     while (win) \{
\par \hich\af1\dbch\af2\loch\f1     \hich\af1\dbch\af2\loch\f1     bool anyrun;
\par 
\par \hich\af1\dbch\af2\loch\f1         anyrun = false;
\par \hich\af1\dbch\af2\loch\f1         for (j = 0; win && j <= fileP; j++) \{
\par \hich\af1\dbch\af2\loch\f1             bool run;
\par 
\par \hich\af1\dbch\af2\loch\f1             run = false;
\par \hich\af1\dbch\af2\loch\f1             if (file[j]->valid) \{
\par \hich\af1\dbch\af2\loch\f1                 if (!compLT(win->key, file[j]->rec.key)) \{
\par \hich\af1\dbch\af2\loch\f1                     /* appe\hich\af1\dbch\af2\loch\f1 nd to an existing run */
\par \hich\af1\dbch\af2\loch\f1                     run = true;
\par \hich\af1\dbch\af2\loch\f1                 \} else if (file[j]->dummy) \{
\par \hich\af1\dbch\af2\loch\f1                     /* start a new run */
\par \hich\af1\dbch\af2\loch\f1                     file[j]->dummy--;
\par \hich\af1\dbch\af2\loch\f1                     run = true;
\par \hich\af1\dbch\af2\loch\f1                 \}
\par \hich\af1\dbch\af2\loch\f1             \} else \{
\par \hich\af1\dbch\af2\loch\f1    \hich\af1\dbch\af2\loch\f1              /* first run in file */
\par \hich\af1\dbch\af2\loch\f1                 file[j]->dummy--;
\par \hich\af1\dbch\af2\loch\f1                 run = true;
\par \hich\af1\dbch\af2\loch\f1             \}
\par 
\par \hich\af1\dbch\af2\loch\f1             if (run) \{
\par \hich\af1\dbch\af2\loch\f1                 anyrun = true;
\par 
\par \hich\af1\dbch\af2\loch\f1                 /* flush run */
\par \hich\af1\dbch\af2\loch\f1                 while(1) \{
\par \hich\af1\dbch\af2\loch\f1                     if (fwri\hich\af1\dbch\af2\loch\f1 te(win, sizeof(recType), 1, file[j]->fp) != 1) \{
\par \hich\af1\dbch\af2\loch\f1                         perror("io3");
\par \hich\af1\dbch\af2\loch\f1                         cleanExit(1);
\par \hich\af1\dbch\af2\loch\f1                     \}
\par \hich\af1\dbch\af2\loch\f1                     file[j]->rec.key = win->key;
\par \hich\af1\dbch\af2\loch\f1                     file[j]->valid = true;
\par \hich\af1\dbch\af2\loch\f1                 \hich\af1\dbch\af2\loch\f1     if ((win = readRec()) == NULL) break;
\par \hich\af1\dbch\af2\loch\f1                     if (compLT(win->key, file[j]->rec.key)) break;
\par \hich\af1\dbch\af2\loch\f1                 \}
\par \hich\af1\dbch\af2\loch\f1             \}
\par \hich\af1\dbch\af2\loch\f1         \}
\par 
\par \hich\af1\dbch\af2\loch\f1         /* if no room for runs, up a level */
\par \hich\af1\dbch\af2\loch\f1         if (!anyrun) \{
\par \hich\af1\dbch\af2\loch\f1             int t;
\par \hich\af1\dbch\af2\loch\f1             leve\hich\af1\dbch\af2\loch\f1 l++;
\par \hich\af1\dbch\af2\loch\f1             t = file[0]->fib;
\par \hich\af1\dbch\af2\loch\f1             for (j = 0; j <= fileP; j++) \{
\par \hich\af1\dbch\af2\loch\f1                 file[j]->dummy = t + file[j+1]->fib - file[j]->fib;
\par \hich\af1\dbch\af2\loch\f1                 file[j]->fib = t + file[j+1]->fib; 
\par \hich\af1\dbch\af2\loch\f1             \}
\par \hich\af1\dbch\af2\loch\f1         \}
\par \hich\af1\dbch\af2\loch\f1     \}
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 void rewindFile(int j) \{
\par \hich\af1\dbch\af2\loch\f1     /* rewind file[j] and read in first record */
\par \hich\af1\dbch\af2\loch\f1     file[j]->eor = false;
\par \hich\af1\dbch\af2\loch\f1     file[j]->eof = false;
\par \hich\af1\dbch\af2\loch\f1     rewind(file[j]->fp);
\par \hich\af1\dbch\af2\loch\f1     if (fread(&file[j]->rec, sizeof(recType), 1, file[j]->fp) != 1) \{
\par \hich\af1\dbch\af2\loch\f1         if (feof(file[j]->fp)) \{
\par \hich\af1\dbch\af2\loch\f1             file[j]->eor =\hich\af1\dbch\af2\loch\f1  true;
\par \hich\af1\dbch\af2\loch\f1             file[j]->eof = true;
\par \hich\af1\dbch\af2\loch\f1         \} else \{
\par \hich\af1\dbch\af2\loch\f1             perror("io5");
\par \hich\af1\dbch\af2\loch\f1             cleanExit(1);
\par \hich\af1\dbch\af2\loch\f1         \}
\par \hich\af1\dbch\af2\loch\f1     \}
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 void mergeSort(void) \{
\par \hich\af1\dbch\af2\loch\f1     int fileT;
\par \hich\af1\dbch\af2\loch\f1     int fileP;
\par \hich\af1\dbch\af2\loch\f1     int j;
\par \hich\af1\dbch\af2\loch\f1     tmpFileType *tfile;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* polyphase merge sort */
\par 
\par \hich\af1\dbch\af2\loch\f1     fi\hich\af1\dbch\af2\loch\f1 leT = nTmpFiles - 1;
\par \hich\af1\dbch\af2\loch\f1     fileP = fileT - 1;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* prime the files */
\par \hich\af1\dbch\af2\loch\f1     for (j = 0; j < fileT; j++) \{
\par \hich\af1\dbch\af2\loch\f1         rewindFile(j);
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     /* each pass through loop merges one run */
\par \hich\af1\dbch\af2\loch\f1     while (level) \{
\par \hich\af1\dbch\af2\loch\f1         while(1) \{
\par \hich\af1\dbch\af2\loch\f1             bool allDummies;
\par \hich\af1\dbch\af2\loch\f1      \hich\af1\dbch\af2\loch\f1        bool anyRuns;
\par 
\par \hich\af1\dbch\af2\loch\f1             /* scan for runs */
\par \hich\af1\dbch\af2\loch\f1             allDummies = true;
\par \hich\af1\dbch\af2\loch\f1             anyRuns = false;
\par \hich\af1\dbch\af2\loch\f1             for (j = 0; j <= fileP; j++) \{
\par \hich\af1\dbch\af2\loch\f1                 if (!file[j]->dummy) \{
\par \hich\af1\dbch\af2\loch\f1                     allDummies = false;
\par \hich\af1\dbch\af2\loch\f1                     \hich\af1\dbch\af2\loch\f1 if (!file[j]->eof) anyRuns = true;
\par \hich\af1\dbch\af2\loch\f1                 \}
\par \hich\af1\dbch\af2\loch\f1             \}
\par 
\par \hich\af1\dbch\af2\loch\f1             if (anyRuns) \{
\par \hich\af1\dbch\af2\loch\f1                 int k;
\par \hich\af1\dbch\af2\loch\f1                 keyType lastKey;
\par 
\par \hich\af1\dbch\af2\loch\f1                 /* merge 1 run file[0]..file[P] --> file[T] */
\par 
\par \hich\af1\dbch\af2\loch\f1                 while(1) \{
\par \hich\af1\dbch\af2\loch\f1              \hich\af1\dbch\af2\loch\f1        /* each pass thru loop writes 1 record to file[fileT] */
\par 
\par \hich\af1\dbch\af2\loch\f1                     /* find smallest key */
\par \hich\af1\dbch\af2\loch\f1                     k = -1;
\par \hich\af1\dbch\af2\loch\f1                     for (j = 0; j <= fileP; j++) \{
\par \hich\af1\dbch\af2\loch\f1                         if (file[j]->eor) continue;
\par \hich\af1\dbch\af2\loch\f1                 \hich\af1\dbch\af2\loch\f1         if (file[j]->dummy) continue;
\par \hich\af1\dbch\af2\loch\f1                         if (k < 0 || 
\par \hich\af1\dbch\af2\loch\f1                         (k!=j && compGT(file[k]->rec.key, file[j]->rec.key)))
\par \hich\af1\dbch\af2\loch\f1                             k = j;
\par \hich\af1\dbch\af2\loch\f1                     \}
\par \hich\af1\dbch\af2\loch\f1                     if (k < 0) break;
\par 
\par \hich\af1\dbch\af2\loch\f1       \hich\af1\dbch\af2\loch\f1               /* write record[k] to file[fileT] */
\par \hich\af1\dbch\af2\loch\f1                     if (fwrite(&file[k]->rec, sizeof(recType), 1, 
\par \hich\af1\dbch\af2\loch\f1                             file[fileT]->fp) != 1) \{
\par \hich\af1\dbch\af2\loch\f1                         perror("io6");
\par \hich\af1\dbch\af2\loch\f1                         cleanExit(1);
\par \hich\af1\dbch\af2\loch\f1         \hich\af1\dbch\af2\loch\f1             \}
\par 
\par \hich\af1\dbch\af2\loch\f1                     /* replace record[k] */
\par \hich\af1\dbch\af2\loch\f1                     lastKey = file[k]->rec.key;
\par \hich\af1\dbch\af2\loch\f1                     if (fread(&file[k]->rec, sizeof(recType), 1,
\par \hich\af1\dbch\af2\loch\f1                             file[k]->fp) == 1) \{
\par \hich\af1\dbch\af2\loch\f1                         /* check fo\hich\af1\dbch\af2\loch\f1 r end of run on file[s] */
\par \hich\af1\dbch\af2\loch\f1                         if (compLT(file[k]->rec.key, lastKey))
\par \hich\af1\dbch\af2\loch\f1                             file[k]->eor = true;
\par \hich\af1\dbch\af2\loch\f1                     \} else if (feof(file[k]->fp)) \{
\par \hich\af1\dbch\af2\loch\f1                         file[k]->eof = true;
\par \hich\af1\dbch\af2\loch\f1                     \hich\af1\dbch\af2\loch\f1     file[k]->eor = true;
\par \hich\af1\dbch\af2\loch\f1                     \} else \{
\par \hich\af1\dbch\af2\loch\f1                         perror("io7");
\par \hich\af1\dbch\af2\loch\f1                         cleanExit(1);
\par \hich\af1\dbch\af2\loch\f1                     \}
\par \hich\af1\dbch\af2\loch\f1                 \}
\par 
\par \hich\af1\dbch\af2\loch\f1                 /* fixup dummies */
\par \hich\af1\dbch\af2\loch\f1                 for (j = 0; j <= fileP; j++) \{
\par \hich\af1\dbch\af2\loch\f1  \hich\af1\dbch\af2\loch\f1                    if (file[j]->dummy) file[j]->dummy--;
\par \hich\af1\dbch\af2\loch\f1                     if (!file[j]->eof) file[j]->eor = false;
\par \hich\af1\dbch\af2\loch\f1                 \}
\par 
\par \hich\af1\dbch\af2\loch\f1             \} else if (allDummies) \{
\par \hich\af1\dbch\af2\loch\f1                 for (j = 0; j <= fileP; j++)
\par \hich\af1\dbch\af2\loch\f1                     file[j]->dummy--;
\par \hich\af1\dbch\af2\loch\f1                 file[fileT]->dummy++;
\par \hich\af1\dbch\af2\loch\f1             \}
\par 
\par \hich\af1\dbch\af2\loch\f1             /* end of run */
\par \hich\af1\dbch\af2\loch\f1             if (file[fileP]->eof && !file[fileP]->dummy) \{
\par \hich\af1\dbch\af2\loch\f1                 /* completed a fibonocci-level */
\par \hich\af1\dbch\af2\loch\f1                 level--;
\par \hich\af1\dbch\af2\loch\f1                 if (!level) \{
\par \hich\af1\dbch\af2\loch\f1          \hich\af1\dbch\af2\loch\f1            /* we're done, file[fileT] contains data */
\par \hich\af1\dbch\af2\loch\f1                     return;
\par \hich\af1\dbch\af2\loch\f1                 \}
\par 
\par \hich\af1\dbch\af2\loch\f1                 /* fileP is exhausted, reopen as new */
\par \hich\af1\dbch\af2\loch\f1                 fclose(file[fileP]->fp);
\par \hich\af1\dbch\af2\loch\f1                 if ((file[fileP]->fp = fopen(file[fileP]-\hich\af1\dbch\af2\loch\f1 >name, "w+b"))
\par \hich\af1\dbch\af2\loch\f1                         }{\f1 \hich\af1\dbch\af2\loch\f1 == NULL) \{
\par \hich\af1\dbch\af2\loch\f1                     perror("io8");
\par \hich\af1\dbch\af2\loch\f1                     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 cleanExit(1);
\par \hich\af1\dbch\af2\loch\f1                 \}
\par \hich\af1\dbch\af2\loch\f1                 file[fileP]->eof = false;
\par \hich\af1\dbch\af2\loch\f1                 file[fileP]->eor = false;
\par 
\par \hich\af1\dbch\af2\loch\f1                 rewindFile(fileT);
\par 
\par \hich\af1\dbch\af2\loch\f1                 /* f[0],f[1]...,f[fileT] <-- f[fileT],f[0]...,f[T-1] */
\par \hich\af1\dbch\af2\loch\f1                 tfile = file[fileT];
\par \hich\af1\dbch\af2\loch\f1                 memmove(file + 1, file, fileT * sizeof(tmpFileType*));
\par \hich\af1\dbch\af2\loch\f1                 file[0] = tfile;
\par 
\par \hich\af1\dbch\af2\loch\f1                 /* start new runs */
\par \hich\af1\dbch\af2\loch\f1    \hich\af1\dbch\af2\loch\f1              for (j = 0; j <= fileP; j++)
\par \hich\af1\dbch\af2\loch\f1                     if (!file[j]->eof) file[j]->eor = false;
\par \hich\af1\dbch\af2\loch\f1             \}
\par \hich\af1\dbch\af2\loch\f1         \}
\par \hich\af1\dbch\af2\loch\f1     \}
\par \}
\par 
\par 
\par \hich\af1\dbch\af2\loch\f1 void extSort(void) \{
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang1031\langfe1040\langnp1031 \hich\af1\dbch\af2\loch\f1 initTmpFiles();
\par \hich\af1\dbch\af2\loch\f1     makeRuns();
\par \hich\af1\dbch\af2\loch\f1     mergeSort();
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 termTmpFiles(0);
\par \}
\par 
\par 
\par \hich\af1\dbch\af2\loch\f1 int mai\hich\af1\dbch\af2\loch\f1 n(int argc, char *argv[]) \{
\par 
\par \hich\af1\dbch\af2\loch\f1     /* command-line:
\par \hich\af1\dbch\af2\loch\f1      *
\par \hich\af1\dbch\af2\loch\f1      *   ext ifName ofName nTmpFiles nNodes
\par \hich\af1\dbch\af2\loch\f1      *
\par \hich\af1\dbch\af2\loch\f1      *   ext in.dat out.dat 5 2000
\par \hich\af1\dbch\af2\loch\f1      *       reads in.dat, sorts using 5 files and 2000 nodes, output to out.dat
\par \hich\af1\dbch\af2\loch\f1      */
\par \hich\af1\dbch\af2\loch\f1     if (argc != 5) \{
\par \hich\af1\dbch\af2\loch\f1    \hich\af1\dbch\af2\loch\f1      printf("%s ifName ofName nTmpFiles nNodes\\n", argv[0]);
\par \hich\af1\dbch\af2\loch\f1         cleanExit(1);
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     ifName = argv[1];
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 ofName = argv[2];
\par \hich\af1\dbch\af2\loch\f1     nTmpFiles = atoi(argv[3]);
\par \hich\af1\dbch\af2\loch\f1     nNodes = atoi(argv[4]);
\par 
\par \hich\af1\dbch\af2\loch\f1     printf("extSort: nFiles=%d, nNodes=%d, lrecl=%d\\n",
\par \hich\af1\dbch\af2\loch\f1       \hich\af1\dbch\af2\loch\f1   nTmpFiles, nNodes, sizeof(recType));
\par 
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 extSort();
\par \hich\af1\dbch\af2\loch\f1     return 0;
\par \}
\par }{\f1\lang2057\langfe1040\langnp2057 \page }{\b\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 /* \hich\af1\dbch\af2\loch\f1 b\hich\af1\dbch\af2\loch\f1 -\hich\af1\dbch\af2\loch\f1 tree */
\par }{\f1\lang2057\langfe1040\langnp2057 
\par }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 #include <stdio.h>
\par \hich\af1\dbch\af2\loch\f1 #include <stdlib.h>
\par \hich\af1\dbch\af2\loch\f1 #include <stdarg.h>
\par \hich\af1\dbch\af2\loch\f1 #include <string.h>
\par 
\par \hich\af1\dbch\af2\loch\f1 /*
\par \hich\af1\dbch\af2\loch\f1  * this file is divided into sections:
\par \hich\af1\dbch\af2\loch\f1  *   stuff you'll probably want to place in a .h file...
\par \hich\af1\dbch\af2\loch\f1  *     implementation dependent
\par \hich\af1\dbch\af2\loch\f1  *       - you'll probably have to change something here
\par \hich\af1\dbch\af2\loch\f1  *    \hich\af1\dbch\af2\loch\f1  implementation independent
\par \hich\af1\dbch\af2\loch\f1  *       - types and function prototypes that typically go in a .h file
\par \hich\af1\dbch\af2\loch\f1  *     function prototypes
\par \hich\af1\dbch\af2\loch\f1  *       - prototypes for user functions
\par \hich\af1\dbch\af2\loch\f1  *   internals
\par \hich\af1\dbch\af2\loch\f1  *     - local functions
\par \hich\af1\dbch\af2\loch\f1  *     - user functions
\par \hich\af1\dbch\af2\loch\f1  }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 *   main()
\par \hich\af1\dbch\af2\loch\f1  */
\par 
\par \hich\af1\dbch\af2\loch\f1 /******\hich\af1\dbch\af2\loch\f1 **********************
\par \hich\af1\dbch\af2\loch\f1  * implementation dependent *
\par \hich\af1\dbch\af2\loch\f1  }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 ****************************/
\par \hich\af1\dbch\af2\loch\f1 typedef long eAdrType;          /* record address for external record */
\par \hich\af1\dbch\af2\loch\f1 typedef long bAdrType;          /* record address for btree node */
\par 
\par }{\f1 \hich\af1\dbch\af2\loch\f1 #define CC_EQ           0
\par \hich\af1\dbch\af2\loch\f1 #def\hich\af1\dbch\af2\loch\f1 ine CC_GT           1
\par \hich\af1\dbch\af2\loch\f1 #define CC_LT          -1
\par 
\par }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 /* compare two keys and return:
\par \hich\af1\dbch\af2\loch\f1  *    CC_LT     key1 < key2
\par \hich\af1\dbch\af2\loch\f1  *    CC_GT     key1 > key2
\par \hich\af1\dbch\af2\loch\f1  *    CC_EQ     key1 = key2
\par \hich\af1\dbch\af2\loch\f1  */
\par \hich\af1\dbch\af2\loch\f1 typedef int (*bCompType)(const void *key1, const void *key2);
\par 
\par \hich\af1\dbch\af2\loch\f1 /***********************\hich\af1\dbch\af2\loch\f1 *******
\par \hich\af1\dbch\af2\loch\f1  * implementation independent *
\par \hich\af1\dbch\af2\loch\f1  ******************************/
\par 
\par \hich\af1\dbch\af2\loch\f1 /* statistics */
\par \hich\af1\dbch\af2\loch\f1 int maxHeight;          /* maximum height attained */
\par \hich\af1\dbch\af2\loch\f1 int nNodesIns;          /* number of nodes inserted */
\par \hich\af1\dbch\af2\loch\f1 int nNodesDel;          /* number of nodes deleted */
\par \hich\af1\dbch\af2\loch\f1 in\hich\af1\dbch\af2\loch\f1 t nKeysIns;           /* number of keys inserted */
\par \hich\af1\dbch\af2\loch\f1 int nKeysDel;           /* number of keys deleted */
\par \hich\af1\dbch\af2\loch\f1 int nDiskReads;         /* number of disk reads */
\par \hich\af1\dbch\af2\loch\f1 int nDiskWrites;        /* number of disk writes */
\par 
\par \hich\af1\dbch\af2\loch\f1 /* line number for last IO or memory error */
\par \hich\af1\dbch\af2\loch\f1 i\hich\af1\dbch\af2\loch\f1 nt bErrLineNo;
\par 
\par \hich\af1\dbch\af2\loch\f1 typedef enum \{false, true\} bool;
\par \hich\af1\dbch\af2\loch\f1 typedef enum \{
\par \hich\af1\dbch\af2\loch\f1     bErrOk,
\par \hich\af1\dbch\af2\loch\f1     bErrKeyNotFound,
\par \hich\af1\dbch\af2\loch\f1     bErrDupKeys,
\par \hich\af1\dbch\af2\loch\f1     bErrSectorSize,
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang1031\langfe1040\langnp1031 \hich\af1\dbch\af2\loch\f1 bErrFileNotOpen,
\par \hich\af1\dbch\af2\loch\f1     bErrFileExists,
\par \hich\af1\dbch\af2\loch\f1     bErrIO,
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 bErrMemory 
\par \}\hich\af1\dbch\af2\loch\f1  bErrType;
\par 
\par \hich\af1\dbch\af2\loch\f1 typedef void *bHandleType;
\par 
\par \hich\af1\dbch\af2\loch\f1 typedef stru\hich\af1\dbch\af2\loch\f1 ct \{                /* info for bOpen() */
\par \hich\af1\dbch\af2\loch\f1     char *iName;                /* name of index file */
\par \hich\af1\dbch\af2\loch\f1     int keySize;                /* length, in bytes, of key */
\par \hich\af1\dbch\af2\loch\f1     int sectorSize;             /* size of sector on disk */
\par \hich\af1\dbch\af2\loch\f1     bCompType comp;             \hich\af1\dbch\af2\loch\f1 /* pointer to compare function */
\par \}\hich\af1\dbch\af2\loch\f1  bOpenType;
\par 
\par \hich\af1\dbch\af2\loch\f1 /***********************
\par \hich\af1\dbch\af2\loch\f1  * function prototypes *
\par \hich\af1\dbch\af2\loch\f1  ***********************/
\par \hich\af1\dbch\af2\loch\f1 bErrType bOpen(bOpenType info, bHandleType *handle);
\par \hich\af1\dbch\af2\loch\f1     /*
\par \hich\af1\dbch\af2\loch\f1      * input:
\par \hich\af1\dbch\af2\loch\f1      *   info                   info for open
\par \hich\af1\dbch\af2\loch\f1      * outpu\hich\af1\dbch\af2\loch\f1 t:
\par \hich\af1\dbch\af2\loch\f1      *   handle                 handle to btree, used in subsequent calls
\par \hich\af1\dbch\af2\loch\f1      * returns:
\par \hich\af1\dbch\af2\loch\f1      *   bErrOk                 open was successful
\par \hich\af1\dbch\af2\loch\f1      *   bErrMemory             insufficient memory
\par \hich\af1\dbch\af2\loch\f1      *   bErrSectorSize         sector size too small or no\hich\af1\dbch\af2\loch\f1 t 0 mod 4
\par \hich\af1\dbch\af2\loch\f1      *   bErrFileNotOpen        unable to open index file
\par \hich\af1\dbch\af2\loch\f1      */
\par 
\par \hich\af1\dbch\af2\loch\f1 bErrType bClose(bHandleType handle);
\par \hich\af1\dbch\af2\loch\f1     /*
\par \hich\af1\dbch\af2\loch\f1      * input:
\par \hich\af1\dbch\af2\loch\f1      *   handle                 handle returned by bOpen
\par \hich\af1\dbch\af2\loch\f1      * returns:
\par \hich\af1\dbch\af2\loch\f1      *   bErrOk                 file closed, res\hich\af1\dbch\af2\loch\f1 ources deleted
\par \hich\af1\dbch\af2\loch\f1      */
\par 
\par \hich\af1\dbch\af2\loch\f1 bErrType bInsertKey(bHandleType handle, void *key, eAdrType rec);
\par \hich\af1\dbch\af2\loch\f1     /*
\par \hich\af1\dbch\af2\loch\f1      * input:
\par \hich\af1\dbch\af2\loch\f1      *   handle                 handle returned by bOpen
\par \hich\af1\dbch\af2\loch\f1      *   key                    key to insert
\par \hich\af1\dbch\af2\loch\f1      *   rec                    record add\hich\af1\dbch\af2\loch\f1 ress
\par \hich\af1\dbch\af2\loch\f1      * returns:
\par \hich\af1\dbch\af2\loch\f1      *   bErrOk                 operation successful
\par \hich\af1\dbch\af2\loch\f1      *   bErrDupKeys            duplicate keys
\par \hich\af1\dbch\af2\loch\f1      */
\par 
\par \hich\af1\dbch\af2\loch\f1 bErrType bDeleteKey(bHandleType handle, void *key);
\par \hich\af1\dbch\af2\loch\f1     /*
\par \hich\af1\dbch\af2\loch\f1      * input:
\par \hich\af1\dbch\af2\loch\f1      *   handle                 handle returned by bO\hich\af1\dbch\af2\loch\f1 pen
\par \hich\af1\dbch\af2\loch\f1      *   key                    key to delete
\par \hich\af1\dbch\af2\loch\f1      * output:
\par \hich\af1\dbch\af2\loch\f1      *   rec                    record address deleted
\par \hich\af1\dbch\af2\loch\f1      * returns:
\par \hich\af1\dbch\af2\loch\f1      *   bErrOk                 operation successful
\par \hich\af1\dbch\af2\loch\f1      *   bErrKeyNotFound        key not found
\par \hich\af1\dbch\af2\loch\f1      */
\par 
\par \hich\af1\dbch\af2\loch\f1 bErrType bFi\hich\af1\dbch\af2\loch\f1 ndKey(bHandleType handle, void *key, eAdrType *rec);
\par \hich\af1\dbch\af2\loch\f1     /*
\par \hich\af1\dbch\af2\loch\f1      * input:
\par \hich\af1\dbch\af2\loch\f1      *   handle                 handle returned by bOpen
\par \hich\af1\dbch\af2\loch\f1      *   key                    key to find
\par \hich\af1\dbch\af2\loch\f1      * output:
\par \hich\af1\dbch\af2\loch\f1      *   rec                    record address
\par \hich\af1\dbch\af2\loch\f1      * returns:
\par \hich\af1\dbch\af2\loch\f1    \hich\af1\dbch\af2\loch\f1   *   bErrOk                 operation successful
\par \hich\af1\dbch\af2\loch\f1      *   bErrKeyNotFound        key not found
\par \hich\af1\dbch\af2\loch\f1      */
\par 
\par \hich\af1\dbch\af2\loch\f1 bErrType bFindFirstKey(bHandleType handle, void *key, eAdrType *rec);
\par \hich\af1\dbch\af2\loch\f1     /*
\par \hich\af1\dbch\af2\loch\f1      * input:
\par \hich\af1\dbch\af2\loch\f1      *   handle                 handle returned by bOpen
\par \hich\af1\dbch\af2\loch\f1    \hich\af1\dbch\af2\loch\f1   * output:
\par \hich\af1\dbch\af2\loch\f1      *   key                    first key in sequential set
\par \hich\af1\dbch\af2\loch\f1      *   rec                    record address
\par \hich\af1\dbch\af2\loch\f1      * returns:
\par \hich\af1\dbch\af2\loch\f1      *   bErrOk                 operation successful
\par \hich\af1\dbch\af2\loch\f1      *   bErrKeyNotFound        key not found
\par \hich\af1\dbch\af2\loch\f1      */
\par 
\par \hich\af1\dbch\af2\loch\f1 bErrType bFin\hich\af1\dbch\af2\loch\f1 dLastKey(bHandleType handle, void *key, eAdrType *rec);
\par \hich\af1\dbch\af2\loch\f1     /*
\par \hich\af1\dbch\af2\loch\f1      * input:
\par \hich\af1\dbch\af2\loch\f1      *   handle                 handle returned by bOpen
\par \hich\af1\dbch\af2\loch\f1      * output:
\par \hich\af1\dbch\af2\loch\f1      *   key                    last key in sequential set
\par \hich\af1\dbch\af2\loch\f1      *   rec                    record address
\par \hich\af1\dbch\af2\loch\f1  \hich\af1\dbch\af2\loch\f1     * returns:
\par \hich\af1\dbch\af2\loch\f1      *   bErrOk                 operation successful
\par \hich\af1\dbch\af2\loch\f1      *   bErrKeyNotFound        key not found
\par \hich\af1\dbch\af2\loch\f1      */
\par 
\par \hich\af1\dbch\af2\loch\f1 bErrType bFindNextKey(bHandleType handle, void *key, eAdrType *rec);
\par \hich\af1\dbch\af2\loch\f1     /*
\par \hich\af1\dbch\af2\loch\f1      * input:
\par \hich\af1\dbch\af2\loch\f1      *   handle                 handle retu\hich\af1\dbch\af2\loch\f1 rned by bOpen
\par \hich\af1\dbch\af2\loch\f1      * output:
\par \hich\af1\dbch\af2\loch\f1      *   key                    key found
\par \hich\af1\dbch\af2\loch\f1      *   rec                    record address
\par \hich\af1\dbch\af2\loch\f1      * returns:
\par \hich\af1\dbch\af2\loch\f1      *   bErrOk                 operation successful
\par \hich\af1\dbch\af2\loch\f1      *   bErrKeyNotFound        key not found
\par \hich\af1\dbch\af2\loch\f1      */
\par 
\par \hich\af1\dbch\af2\loch\f1 bErrType bFind\hich\af1\dbch\af2\loch\f1 PrevKey(bHandleType handle, void *key, eAdrType *rec);
\par \hich\af1\dbch\af2\loch\f1     /*
\par \hich\af1\dbch\af2\loch\f1      * input:
\par \hich\af1\dbch\af2\loch\f1      *   handle                 handle returned by bOpen
\par \hich\af1\dbch\af2\loch\f1      * output:
\par \hich\af1\dbch\af2\loch\f1      *   key                    key found
\par \hich\af1\dbch\af2\loch\f1      *   rec                    record address
\par \hich\af1\dbch\af2\loch\f1      * returns:
\par \hich\af1\dbch\af2\loch\f1    \hich\af1\dbch\af2\loch\f1   *   bErrOk                 operation successful
\par \hich\af1\dbch\af2\loch\f1      *   bErrKeyNotFound        key not found
\par \hich\af1\dbch\af2\loch\f1      */
\par 
\par \hich\af1\dbch\af2\loch\f1 /*************
\par \hich\af1\dbch\af2\loch\f1  * internals *
\par \hich\af1\dbch\af2\loch\f1  *************/
\par 
\par \hich\af1\dbch\af2\loch\f1 /*
\par \hich\af1\dbch\af2\loch\f1  *  algorithm:
\par \hich\af1\dbch\af2\loch\f1  *    A B+tree implementation, with keys stored in internal nodes,
\par \hich\af1\dbch\af2\loch\f1  *    and keys/reco\hich\af1\dbch\af2\loch\f1 rd addresses stored in leaf nodes.  Each node is
\par \hich\af1\dbch\af2\loch\f1  *    one sector in length, except the root node whose length is
\par \hich\af1\dbch\af2\loch\f1  *    3 sectors.  When traversing the tree to insert a key, full
\par \hich\af1\dbch\af2\loch\f1  *    children are adjusted to make room for possible new entries.
\par \hich\af1\dbch\af2\loch\f1  *    Simi\hich\af1\dbch\af2\loch\f1 larly, on deletion, half-full nodes are adjusted to allow for
\par \hich\af1\dbch\af2\loch\f1  *    possible deleted entries.  Adjustments are first done by 
\par \hich\af1\dbch\af2\loch\f1  *    examining 2 nearest neighbors at the same level, and redistibuting
\par \hich\af1\dbch\af2\loch\f1  *    the keys if possible.  If redistribution won't solv\hich\af1\dbch\af2\loch\f1 e the problem,
\par \hich\af1\dbch\af2\loch\f1  *    nodes are split/joined as needed.  Typically, a node is 3/4 full.
\par \hich\af1\dbch\af2\loch\f1  *    On insertion, if 3 nodes are full, they are split into 4 nodes,
\par \hich\af1\dbch\af2\loch\f1  *    each 3/4 full.  On deletion, if 3 nodes are 1/2 full, they are
\par \hich\af1\dbch\af2\loch\f1  *    joined to create 2 nodes\hich\af1\dbch\af2\loch\f1  3/4 full.
\par \hich\af1\dbch\af2\loch\f1  *
\par \hich\af1\dbch\af2\loch\f1  *    A LRR (least-recently-read) buffering scheme for nodes is used to
\par \hich\af1\dbch\af2\loch\f1  *    simplify storage management, and, assuming some locality of reference,
\par \hich\af1\dbch\af2\loch\f1  *    improve performance.
\par \hich\af1\dbch\af2\loch\f1  *
\par \hich\af1\dbch\af2\loch\f1  *    To simplify matters, both internal nodes and leafs contai\hich\af1\dbch\af2\loch\f1 n the
\par \hich\af1\dbch\af2\loch\f1  *    same fields.
\par \hich\af1\dbch\af2\loch\f1  *   
\par \hich\af1\dbch\af2\loch\f1  */
\par 
\par \hich\af1\dbch\af2\loch\f1 /* macros for addressing fields */
\par 
\par \hich\af1\dbch\af2\loch\f1 /* primitives */
\par \hich\af1\dbch\af2\loch\f1 #define bAdr(p) *(bAdrType *)(p)
\par \hich\af1\dbch\af2\loch\f1 #define eAdr(p) *(eAdrType *)(p)
\par 
\par \hich\af1\dbch\af2\loch\f1 /* based on k = &[key,rec,childGE] */
\par \hich\af1\dbch\af2\loch\f1 #define childLT(k) bAdr((char *)k - sizeof(bAdrType))
\par \hich\af1\dbch\af2\loch\f1 #define \hich\af1\dbch\af2\loch\f1 key(k) (k)
\par \hich\af1\dbch\af2\loch\f1 #define rec(k) eAdr((char *)(k) + h->keySize)
\par \hich\af1\dbch\af2\loch\f1 #define childGE(k) bAdr((char *)(k) + h->keySize + sizeof(eAdrType))
\par 
\par \hich\af1\dbch\af2\loch\f1 /* based on b = &bufType */
\par \hich\af1\dbch\af2\loch\f1 #define leaf(b) b->p->leaf
\par \hich\af1\dbch\af2\loch\f1 #define ct(b) b->p->ct
\par \hich\af1\dbch\af2\loch\f1 #define next(b) b->p->next
\par \hich\af1\dbch\af2\loch\f1 #define prev(b) b->p->pr\hich\af1\dbch\af2\loch\f1 ev
\par \hich\af1\dbch\af2\loch\f1 #define fkey(b) &b->p->fkey
\par \hich\af1\dbch\af2\loch\f1 #define lkey(b) (fkey(b) + ks((ct(b) - 1)))
\par \hich\af1\dbch\af2\loch\f1 #define p(b) (char *)(b->p)
\par 
\par \hich\af1\dbch\af2\loch\f1 /* shortcuts */
\par \hich\af1\dbch\af2\loch\f1 #define ks(ct) ((ct) * h->ks)
\par 
\par \hich\af1\dbch\af2\loch\f1 typedef char keyType;           /* keys entries are treated as char arrays */
\par 
\par \hich\af1\dbch\af2\loch\f1 typedef struct \{
\par \hich\af1\dbch\af2\loch\f1     unsig\hich\af1\dbch\af2\loch\f1 ned int leaf:1;        /* first bit = 1 if leaf */
\par \hich\af1\dbch\af2\loch\f1     unsigned int ct:15;         /* count of keys present */
\par \hich\af1\dbch\af2\loch\f1     bAdrType prev;              /* prev node in sequence (leaf) */
\par \hich\af1\dbch\af2\loch\f1     bAdrType next;              /* next node in sequence (leaf) */
\par \hich\af1\dbch\af2\loch\f1     bAdrTyp\hich\af1\dbch\af2\loch\f1 e childLT;           /* child LT first key */
\par \hich\af1\dbch\af2\loch\f1     /* ct occurrences of [key,rec,childGE] */
\par \hich\af1\dbch\af2\loch\f1     keyType fkey;               /* first occurrence */
\par \}\hich\af1\dbch\af2\loch\f1  nodeType;
\par 
\par \hich\af1\dbch\af2\loch\f1 typedef struct bufTypeTag \{     /* location of node */
\par \hich\af1\dbch\af2\loch\f1     struct bufTypeTag *next;    /* next *\hich\af1\dbch\af2\loch\f1 /
\par \hich\af1\dbch\af2\loch\f1     struct bufTypeTag *prev;    /* previous */
\par \hich\af1\dbch\af2\loch\f1     bAdrType adr;               /* on disk */
\par \hich\af1\dbch\af2\loch\f1     nodeType *p;                /* in memory */
\par \hich\af1\dbch\af2\loch\f1     bool valid;                 /* true if buffer contents valid */
\par \hich\af1\dbch\af2\loch\f1     bool modified;              /* true if bu\hich\af1\dbch\af2\loch\f1 ffer modified */
\par \}\hich\af1\dbch\af2\loch\f1  bufType;
\par 
\par \hich\af1\dbch\af2\loch\f1 /* one node for each open handle */
\par \hich\af1\dbch\af2\loch\f1 typedef struct hNodeTag \{
\par \hich\af1\dbch\af2\loch\f1     struct hNodeTag *prev;      /* previous node */
\par \hich\af1\dbch\af2\loch\f1     struct hNodeTag *next;      /* next node */
\par \hich\af1\dbch\af2\loch\f1     FILE *fp;                   /* idx file */
\par \hich\af1\dbch\af2\loch\f1     int keySize;  \hich\af1\dbch\af2\loch\f1               /* key length */
\par \hich\af1\dbch\af2\loch\f1     int sectorSize;             /* block size for idx records */
\par \hich\af1\dbch\af2\loch\f1     bCompType comp;             /* pointer to compare routine */
\par \hich\af1\dbch\af2\loch\f1     bufType root;               /* root of b-tree, room for 3 sets */
\par \hich\af1\dbch\af2\loch\f1     bufType bufList;     \hich\af1\dbch\af2\loch\f1        /* head of buf list */
\par \hich\af1\dbch\af2\loch\f1     void *malloc1;              /* malloc'd resources */
\par \hich\af1\dbch\af2\loch\f1     void *malloc2;              /* malloc'd resources */
\par \hich\af1\dbch\af2\loch\f1     bufType gbuf;               /* gather buffer, room for 3 sets */
\par \hich\af1\dbch\af2\loch\f1     bufType *curBuf;            /* current \hich\af1\dbch\af2\loch\f1 location */
\par \hich\af1\dbch\af2\loch\f1     keyType *curKey;            /* current key in current node */
\par \hich\af1\dbch\af2\loch\f1     unsigned int maxCt;         /* minimum # keys in node */
\par \hich\af1\dbch\af2\loch\f1     int ks;                     /* sizeof key entry */
\par \hich\af1\dbch\af2\loch\f1     bAdrType nextFreeAdr;       /* next free b-tree record add\hich\af1\dbch\af2\loch\f1 ress */
\par \}\hich\af1\dbch\af2\loch\f1  hNode;
\par 
\par \hich\af1\dbch\af2\loch\f1 static hNode hList;             /* list of hNodes */
\par \hich\af1\dbch\af2\loch\f1 static hNode *h;                /* current hNode */
\par 
\par \hich\af1\dbch\af2\loch\f1 #define error(rc) lineError(__LINE__, rc)
\par 
\par \hich\af1\dbch\af2\loch\f1 static bErrType lineError(int lineno, bErrType rc) \{
\par \hich\af1\dbch\af2\loch\f1     if (rc == bErrIO || rc == bErrMe\hich\af1\dbch\af2\loch\f1 mory)
\par \hich\af1\dbch\af2\loch\f1         if (!bErrLineNo) 
\par \hich\af1\dbch\af2\loch\f1             bErrLineNo = lineno;
\par \hich\af1\dbch\af2\loch\f1     return rc;
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 static bAdrType allocAdr(void) \{
\par \hich\af1\dbch\af2\loch\f1     bAdrType adr;
\par \hich\af1\dbch\af2\loch\f1     adr = h->nextFreeAdr;
\par \hich\af1\dbch\af2\loch\f1     h->nextFreeAdr += h->sectorSize;
\par \hich\af1\dbch\af2\loch\f1     return adr;
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 static bErrType flush(bufType *buf) \{
\par \hich\af1\dbch\af2\loch\f1   \hich\af1\dbch\af2\loch\f1   int len;            /* number of bytes to write */
\par 
\par \hich\af1\dbch\af2\loch\f1     /* flush buffer to disk */
\par \hich\af1\dbch\af2\loch\f1     len = h->sectorSize;
\par \hich\af1\dbch\af2\loch\f1     if (buf->adr == 0) len *= 3;        /* root */
\par \hich\af1\dbch\af2\loch\f1     if (fseek(h->fp, buf->adr, SEEK_SET)) return error(bErrIO);
\par \hich\af1\dbch\af2\loch\f1     if (fwrite(buf->p, len, 1, \hich\af1\dbch\af2\loch\f1 h->fp) != 1) return error(bErrIO);
\par \hich\af1\dbch\af2\loch\f1     buf->modified = false;
\par \hich\af1\dbch\af2\loch\f1     nDiskWrites++;
\par \hich\af1\dbch\af2\loch\f1     return bErrOk;
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 static bErrType flushAll(void) \{
\par \hich\af1\dbch\af2\loch\f1     bErrType rc;                /* return code */
\par \hich\af1\dbch\af2\loch\f1     bufType *buf;               /* buffer */
\par 
\par \hich\af1\dbch\af2\loch\f1     if (h->root.modified\hich\af1\dbch\af2\loch\f1 )
\par \hich\af1\dbch\af2\loch\f1         if ((rc = flush(&h->root)) != 0) return rc;
\par 
\par \hich\af1\dbch\af2\loch\f1     buf = h->bufList.next;
\par \hich\af1\dbch\af2\loch\f1     while (buf != &h->bufList) \{
\par \hich\af1\dbch\af2\loch\f1         if (buf->modified)
\par \hich\af1\dbch\af2\loch\f1             if ((rc = flush(buf)) != 0) return rc;
\par \hich\af1\dbch\af2\loch\f1         buf = buf->next;
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     return bErrOk;
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 static bEr\hich\af1\dbch\af2\loch\f1 rType assignBuf(bAdrType adr, bufType **b) \{
\par \hich\af1\dbch\af2\loch\f1     /* assign buf to adr */
\par \hich\af1\dbch\af2\loch\f1     bufType *buf;               /* buffer */
\par \hich\af1\dbch\af2\loch\f1     bErrType rc;                /* return code */
\par 
\par \hich\af1\dbch\af2\loch\f1     if (adr == 0) \{
\par \hich\af1\dbch\af2\loch\f1         *b = &h->root;
\par \hich\af1\dbch\af2\loch\f1         return bErrOk;
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     /* search \hich\af1\dbch\af2\loch\f1 for buf with matching adr */
\par \hich\af1\dbch\af2\loch\f1     buf = h->bufList.next;
\par \hich\af1\dbch\af2\loch\f1     while (buf->next != &h->bufList) \{
\par \hich\af1\dbch\af2\loch\f1         if (buf->valid && buf->adr == adr) break;
\par \hich\af1\dbch\af2\loch\f1         buf = buf->next;
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     /* either buf points to a match, or it's last one in list (LRR) */
\par \hich\af1\dbch\af2\loch\f1     if (\hich\af1\dbch\af2\loch\f1 buf->valid) \{
\par \hich\af1\dbch\af2\loch\f1         if (buf->adr != adr) \{
\par \hich\af1\dbch\af2\loch\f1             if (buf->modified) \{
\par \hich\af1\dbch\af2\loch\f1                 if ((rc = flush(buf)) != 0) return rc;
\par \hich\af1\dbch\af2\loch\f1             }{\f1\lang1031\langfe1040\langnp1031 \}
\par \hich\af1\dbch\af2\loch\f1             buf->adr = adr;
\par \hich\af1\dbch\af2\loch\f1             }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 buf->valid = false;
\par \hich\af1\dbch\af2\loch\f1         \}
\par \hich\af1\dbch\af2\loch\f1     \} else \{
\par \hich\af1\dbch\af2\loch\f1         buf->adr = adr;
\par \hich\af1\dbch\af2\loch\f1   \hich\af1\dbch\af2\loch\f1   \}
\par 
\par \hich\af1\dbch\af2\loch\f1     /* remove from current position and place at front of list */
\par \hich\af1\dbch\af2\loch\f1     buf->next->prev = buf->prev;
\par \hich\af1\dbch\af2\loch\f1     buf->prev->next = buf->next;
\par \hich\af1\dbch\af2\loch\f1     buf->next = h->bufList.next;
\par \hich\af1\dbch\af2\loch\f1     buf->prev = &h->bufList;
\par \hich\af1\dbch\af2\loch\f1     buf->next->prev = buf;
\par \hich\af1\dbch\af2\loch\f1     buf->prev->next = buf;
\par \hich\af1\dbch\af2\loch\f1    \hich\af1\dbch\af2\loch\f1  *b = buf;
\par \hich\af1\dbch\af2\loch\f1     return bErrOk;
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 static bErrType writeDisk(bufType *buf) \{
\par \hich\af1\dbch\af2\loch\f1     /* write buf to disk */
\par \hich\af1\dbch\af2\loch\f1     buf->valid = true;
\par \hich\af1\dbch\af2\loch\f1     buf->modified = true;
\par \hich\af1\dbch\af2\loch\f1     return bErrOk;
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 static bErrType readDisk(bAdrType adr, bufType **b) \{
\par \hich\af1\dbch\af2\loch\f1     /* read data into buf */
\par \hich\af1\dbch\af2\loch\f1     int len;
\par \hich\af1\dbch\af2\loch\f1     bufType *buf;               /* buffer */
\par \hich\af1\dbch\af2\loch\f1     bErrType rc;                /* return code */
\par 
\par \hich\af1\dbch\af2\loch\f1     if ((rc = assignBuf(adr, &buf)) != 0) return rc;
\par \hich\af1\dbch\af2\loch\f1     if (!buf->valid) \{
\par \hich\af1\dbch\af2\loch\f1         len = h->sectorSize;
\par \hich\af1\dbch\af2\loch\f1         if (adr == 0) len *= 3;         /\hich\af1\dbch\af2\loch\f1 * root */
\par \hich\af1\dbch\af2\loch\f1         if (fseek(h->fp, adr, SEEK_SET)) return error(bErrIO);
\par \hich\af1\dbch\af2\loch\f1         if (fread(buf->p, len, 1, h->fp) != 1) return error(bErrIO);
\par \hich\af1\dbch\af2\loch\f1         buf->modified = false;
\par \hich\af1\dbch\af2\loch\f1         buf->valid = true;
\par \hich\af1\dbch\af2\loch\f1         nDiskReads++;
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     *b = buf;
\par \hich\af1\dbch\af2\loch\f1     return bEr\hich\af1\dbch\af2\loch\f1 rOk;
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 typedef enum \{ MODE_FIRST, MODE_MATCH \} modeEnum;
\par 
\par \hich\af1\dbch\af2\loch\f1 static int search(
\par \hich\af1\dbch\af2\loch\f1     bufType *buf,
\par \hich\af1\dbch\af2\loch\f1     void *key, 
\par \hich\af1\dbch\af2\loch\f1     keyType **mkey,
\par \hich\af1\dbch\af2\loch\f1     modeEnum mode) \{
\par \hich\af1\dbch\af2\loch\f1     /*
\par \hich\af1\dbch\af2\loch\f1      * input:
\par \hich\af1\dbch\af2\loch\f1      *   p                      pointer to node
\par \hich\af1\dbch\af2\loch\f1      *   key                    ke\hich\af1\dbch\af2\loch\f1 y to find
\par \hich\af1\dbch\af2\loch\f1      *   rec                    record address
\par \hich\af1\dbch\af2\loch\f1      * output:
\par \hich\af1\dbch\af2\loch\f1      *   k                      pointer to keyType info
\par \hich\af1\dbch\af2\loch\f1      * returns:
\par \hich\af1\dbch\af2\loch\f1      *   CC_EQ                  key = mkey
\par \hich\af1\dbch\af2\loch\f1      *   CC_LT                  key < mkey
\par \hich\af1\dbch\af2\loch\f1      *   CC_GT            \hich\af1\dbch\af2\loch\f1       key > mkey
\par \hich\af1\dbch\af2\loch\f1      }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 */
\par \hich\af1\dbch\af2\loch\f1     int cc;                     /* condition code */
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 int m;                      /* midpoint of search */
\par \hich\af1\dbch\af2\loch\f1     int lb;                     /* lower-bound of binary search */
\par \hich\af1\dbch\af2\loch\f1     int ub;                     /* upper-bound of bina\hich\af1\dbch\af2\loch\f1 ry search */
\par \hich\af1\dbch\af2\loch\f1     bool foundDup;              /* true if found a duplicate key */
\par 
\par \hich\af1\dbch\af2\loch\f1     /* scan current node for key using binary search */
\par \hich\af1\dbch\af2\loch\f1     foundDup = false;
\par \hich\af1\dbch\af2\loch\f1     lb = 0; 
\par \hich\af1\dbch\af2\loch\f1     ub = ct(buf) - 1;
\par \hich\af1\dbch\af2\loch\f1     while (lb <= ub) \{
\par \hich\af1\dbch\af2\loch\f1         }{\f1\lang1031\langfe1040\langnp1031 \hich\af1\dbch\af2\loch\f1 m = (lb + ub) / 2;
\par \hich\af1\dbch\af2\loch\f1         }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 *mk\hich\af1\dbch\af2\loch\f1 ey = fkey(buf) + ks(m);
\par \hich\af1\dbch\af2\loch\f1         cc = h->comp(key, key(*mkey));
\par \hich\af1\dbch\af2\loch\f1         if (cc < 0)
\par \hich\af1\dbch\af2\loch\f1             /* key less than key[m] */
\par \hich\af1\dbch\af2\loch\f1             ub = m - 1;
\par \hich\af1\dbch\af2\loch\f1         else if (cc > 0)
\par \hich\af1\dbch\af2\loch\f1             /* key greater than key[m] */
\par \hich\af1\dbch\af2\loch\f1             lb = m + 1;
\par \hich\af1\dbch\af2\loch\f1         else \{
\par \hich\af1\dbch\af2\loch\f1     \hich\af1\dbch\af2\loch\f1         /* keys match */
\par \hich\af1\dbch\af2\loch\f1             return cc;
\par \hich\af1\dbch\af2\loch\f1         \}
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     if (ct(buf) == 0) \{
\par \hich\af1\dbch\af2\loch\f1         /* empty list */
\par \hich\af1\dbch\af2\loch\f1         *mkey = fkey(buf);
\par \hich\af1\dbch\af2\loch\f1         return CC_LT;
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     /* didn't find key */
\par \hich\af1\dbch\af2\loch\f1     return cc;
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 static bErrType scatterRoot(void) \{
\par \hich\af1\dbch\af2\loch\f1     buf\hich\af1\dbch\af2\loch\f1 Type *gbuf;
\par \hich\af1\dbch\af2\loch\f1     bufType *root;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* scatter gbuf to root */
\par 
\par \hich\af1\dbch\af2\loch\f1     root = &h->root;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang1031\langfe1040\langnp1031 \hich\af1\dbch\af2\loch\f1 gbuf = &h->gbuf;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 memcpy(fkey(root), fkey(gbuf), ks(ct(gbuf)));
\par \hich\af1\dbch\af2\loch\f1     childLT(fkey(root)) = childLT(fkey(gbuf));
\par \hich\af1\dbch\af2\loch\f1     ct(root) = ct(gbuf);
\par \hich\af1\dbch\af2\loch\f1     leaf(root) = leaf(gbuf);
\par \hich\af1\dbch\af2\loch\f1     return bErrOk;
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 static bErrType scatter(bufType *pbuf, keyType *pkey, int is, bufType **tmp) \{
\par \hich\af1\dbch\af2\loch\f1     bufType *gbuf;              /* gather buf */
\par \hich\af1\dbch\af2\loch\f1     keyType *gkey;              /* gather buf key */
\par \hich\af1\dbch\af2\loch\f1     bErrType rc;                /* return code */
\par \hich\af1\dbch\af2\loch\f1   \hich\af1\dbch\af2\loch\f1   int iu;                     /* number of tmp's used */
\par \hich\af1\dbch\af2\loch\f1     int k0Min;                  /* min #keys that can be mapped to tmp[0] */
\par \hich\af1\dbch\af2\loch\f1     int knMin;                  /* min #keys that can be mapped to tmp[1..3] */
\par \hich\af1\dbch\af2\loch\f1     int k0Max;                  /* max #ke\hich\af1\dbch\af2\loch\f1 ys that can be mapped to tmp[0] */
\par \hich\af1\dbch\af2\loch\f1     int knMax;                  /* max #keys that can be mapped to tmp[1..3] */
\par \hich\af1\dbch\af2\loch\f1     int sw;                     /* shift width */
\par \hich\af1\dbch\af2\loch\f1     int len;                    /* length of remainder of buf */
\par \hich\af1\dbch\af2\loch\f1     int base;             \hich\af1\dbch\af2\loch\f1       /* base count distributed to tmps */
\par \hich\af1\dbch\af2\loch\f1     int extra;                  /* extra counts */
\par \hich\af1\dbch\af2\loch\f1     int ct;
\par \hich\af1\dbch\af2\loch\f1     int i;
\par 
\par \hich\af1\dbch\af2\loch\f1     /*
\par \hich\af1\dbch\af2\loch\f1      * input:
\par \hich\af1\dbch\af2\loch\f1      *   pbuf                   parent buffer of gathered keys
\par \hich\af1\dbch\af2\loch\f1      *   pkey                   where we insert a key \hich\af1\dbch\af2\loch\f1 if needed in parent
\par \hich\af1\dbch\af2\loch\f1      *   is                     number of supplied tmps
\par \hich\af1\dbch\af2\loch\f1      *   tmp                    array of tmp's to be used for scattering
\par \hich\af1\dbch\af2\loch\f1      * output:
\par \hich\af1\dbch\af2\loch\f1      *   tmp                    array of tmp's used for scattering
\par \hich\af1\dbch\af2\loch\f1      */
\par 
\par \hich\af1\dbch\af2\loch\f1     /* scatter g\hich\af1\dbch\af2\loch\f1 buf to tmps, placing 3/4 max in each tmp */
\par 
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang1031\langfe1040\langnp1031 \hich\af1\dbch\af2\loch\f1 gbuf = &h->gbuf;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 gkey = fkey(gbuf);
\par \hich\af1\dbch\af2\loch\f1     ct = ct(gbuf);
\par 
\par \hich\af1\dbch\af2\loch\f1    /****************************************
\par \hich\af1\dbch\af2\loch\f1     * determine number of tmps to use (iu) *
\par \hich\af1\dbch\af2\loch\f1     ****************************************/
\par \hich\af1\dbch\af2\loch\f1     iu = is\hich\af1\dbch\af2\loch\f1 ;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* determine limits */
\par \hich\af1\dbch\af2\loch\f1     if (leaf(gbuf)) \{
\par \hich\af1\dbch\af2\loch\f1         /* minus 1 to allow for insertion */
\par \hich\af1\dbch\af2\loch\f1         k0Max= h->maxCt - 1;
\par \hich\af1\dbch\af2\loch\f1         knMax= h->maxCt - 1;
\par \hich\af1\dbch\af2\loch\f1         /* plus 1 to allow for deletion */
\par \hich\af1\dbch\af2\loch\f1         }{\f1\lang1031\langfe1040\langnp1031 \hich\af1\dbch\af2\loch\f1 k0Min= (h->maxCt / 2) + 1;
\par \hich\af1\dbch\af2\loch\f1         knMin= (h->maxC\hich\af1\dbch\af2\loch\f1 t / 2) + 1;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \}\hich\af1\dbch\af2\loch\f1  else \{
\par \hich\af1\dbch\af2\loch\f1         /* can hold an extra gbuf key as it's translated to a LT pointer */
\par \hich\af1\dbch\af2\loch\f1         k0Max = h->maxCt - 1;
\par \hich\af1\dbch\af2\loch\f1         knMax = h->maxCt;
\par \hich\af1\dbch\af2\loch\f1         k0Min = (h->maxCt / 2) + 1;
\par \hich\af1\dbch\af2\loch\f1         }{\f1\lang1031\langfe1040\langnp1031 \hich\af1\dbch\af2\loch\f1 knMin = ((h->maxCt+1) / 2) + 1;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \}
\par 
\par \hich\af1\dbch\af2\loch\f1     /* calculate\hich\af1\dbch\af2\loch\f1  iu, number of tmps to use */
\par \hich\af1\dbch\af2\loch\f1     while(1) \{
\par \hich\af1\dbch\af2\loch\f1         if (iu == 0 || ct > (k0Max + (iu-1)*knMax)) \{
\par \hich\af1\dbch\af2\loch\f1             /* add a buffer */
\par \hich\af1\dbch\af2\loch\f1             if ((rc = assignBuf(allocAdr(), &tmp[iu])) != 0) 
\par \hich\af1\dbch\af2\loch\f1                 return rc;
\par \hich\af1\dbch\af2\loch\f1             /* update sequential link\hich\af1\dbch\af2\loch\f1 s */
\par \hich\af1\dbch\af2\loch\f1             if (leaf(gbuf)) \{
\par \hich\af1\dbch\af2\loch\f1                 /* adjust sequential links */
\par \hich\af1\dbch\af2\loch\f1                 if (iu == 0) \{
\par \hich\af1\dbch\af2\loch\f1                     /* no tmps supplied when splitting root for first time */
\par \hich\af1\dbch\af2\loch\f1                     prev(tmp[0]) = 0;
\par \hich\af1\dbch\af2\loch\f1                     next(tmp\hich\af1\dbch\af2\loch\f1 [0]) = 0;
\par \hich\af1\dbch\af2\loch\f1                 \} else \{
\par \hich\af1\dbch\af2\loch\f1                     prev(tmp[iu]) = tmp[iu-1]->adr;
\par \hich\af1\dbch\af2\loch\f1                     next(tmp[iu]) = next(tmp[iu-1]);
\par \hich\af1\dbch\af2\loch\f1                     next(tmp[iu-1]) = tmp[iu]->adr;
\par \hich\af1\dbch\af2\loch\f1                 \}
\par \hich\af1\dbch\af2\loch\f1             \}
\par \hich\af1\dbch\af2\loch\f1             iu++;
\par \hich\af1\dbch\af2\loch\f1             nN\hich\af1\dbch\af2\loch\f1 odesIns++;
\par \hich\af1\dbch\af2\loch\f1         \} else if (iu > 1 && ct < (k0Min + (iu-1)*knMin)) \{
\par \hich\af1\dbch\af2\loch\f1             }{\f1 \hich\af1\dbch\af2\loch\f1 /* del a buffer */
\par \hich\af1\dbch\af2\loch\f1             }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 iu--;
\par \hich\af1\dbch\af2\loch\f1             /* adjust sequential links */
\par \hich\af1\dbch\af2\loch\f1             if (leaf(gbuf) && tmp[iu-1]->adr) \{
\par \hich\af1\dbch\af2\loch\f1                 next(tmp[iu-1]) = next(tmp[iu]\hich\af1\dbch\af2\loch\f1 );
\par \hich\af1\dbch\af2\loch\f1             \}
\par \hich\af1\dbch\af2\loch\f1             next(tmp[iu-1]) = next(tmp[iu]);
\par \hich\af1\dbch\af2\loch\f1             nNodesDel++;
\par \hich\af1\dbch\af2\loch\f1         \} else \{
\par \hich\af1\dbch\af2\loch\f1             break;
\par \hich\af1\dbch\af2\loch\f1         \}
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     /* establish count for each tmp used */
\par \hich\af1\dbch\af2\loch\f1     }{\f1 \hich\af1\dbch\af2\loch\f1 base = ct / iu;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 extra = ct % iu;
\par \hich\af1\dbch\af2\loch\f1     for (i = 0; i < iu; i++) \{
\par \hich\af1\dbch\af2\loch\f1         int n;
\par 
\par \hich\af1\dbch\af2\loch\f1         n = base;
\par \hich\af1\dbch\af2\loch\f1         /* distribute extras, one at a time */
\par \hich\af1\dbch\af2\loch\f1         /* don't do to 1st node, as it may be internal and can't hold it */
\par \hich\af1\dbch\af2\loch\f1         if (i && extra) \{
\par \hich\af1\dbch\af2\loch\f1             n++;
\par \hich\af1\dbch\af2\loch\f1             extra--;
\par \hich\af1\dbch\af2\loch\f1         \}
\par \hich\af1\dbch\af2\loch\f1         ct(tmp[i]) = n;
\par \hich\af1\dbch\af2\loch\f1  \hich\af1\dbch\af2\loch\f1    \}
\par 
\par 
\par \hich\af1\dbch\af2\loch\f1     /**************************************
\par \hich\af1\dbch\af2\loch\f1      * update sequential links and parent *
\par \hich\af1\dbch\af2\loch\f1      **************************************/
\par \hich\af1\dbch\af2\loch\f1     if (iu != is) \{
\par \hich\af1\dbch\af2\loch\f1         /* link last node to next */
\par \hich\af1\dbch\af2\loch\f1         if (leaf(gbuf) && next(tmp[iu-1])) \{
\par \hich\af1\dbch\af2\loch\f1             bu\hich\af1\dbch\af2\loch\f1 fType *buf;
\par \hich\af1\dbch\af2\loch\f1             if ((rc = readDisk(next(tmp[iu-1]), &buf)) != 0) return rc;
\par \hich\af1\dbch\af2\loch\f1             prev(buf) = tmp[iu-1]->adr;
\par \hich\af1\dbch\af2\loch\f1             if ((rc = writeDisk(buf)) != 0) return rc;
\par \hich\af1\dbch\af2\loch\f1         \}
\par \hich\af1\dbch\af2\loch\f1         /* shift keys in parent */
\par \hich\af1\dbch\af2\loch\f1         sw = ks(iu - is);
\par \hich\af1\dbch\af2\loch\f1       \hich\af1\dbch\af2\loch\f1   if (sw < 0) \{
\par \hich\af1\dbch\af2\loch\f1             len = ks(ct(pbuf)) - (pkey - fkey(pbuf)) + sw;
\par \hich\af1\dbch\af2\loch\f1             memmove(pkey, pkey - sw, len);
\par \hich\af1\dbch\af2\loch\f1         \} else \{
\par \hich\af1\dbch\af2\loch\f1             len = ks(ct(pbuf)) - (pkey - fkey(pbuf));
\par \hich\af1\dbch\af2\loch\f1             memmove(pkey + sw, pkey, len);
\par \hich\af1\dbch\af2\loch\f1         \}
\par \hich\af1\dbch\af2\loch\f1         /* don\hich\af1\dbch\af2\loch\f1 't count LT buffer for empty parent */
\par \hich\af1\dbch\af2\loch\f1         if (ct(pbuf))
\par \hich\af1\dbch\af2\loch\f1             ct(pbuf) += iu - is;
\par \hich\af1\dbch\af2\loch\f1         else
\par \hich\af1\dbch\af2\loch\f1             ct(pbuf) += iu - is - 1;
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1    /*******************************
\par \hich\af1\dbch\af2\loch\f1     * distribute keys to children *
\par \hich\af1\dbch\af2\loch\f1     *****************************\hich\af1\dbch\af2\loch\f1 **/
\par \hich\af1\dbch\af2\loch\f1     for (i = 0; i < iu; i++) \{
\par 
\par \hich\af1\dbch\af2\loch\f1         /* update LT pointer and parent nodes */
\par \hich\af1\dbch\af2\loch\f1         if (leaf(gbuf)) \{
\par \hich\af1\dbch\af2\loch\f1             /* update LT, tmp[i] */
\par \hich\af1\dbch\af2\loch\f1             childLT(fkey(tmp[i])) = 0;
\par 
\par \hich\af1\dbch\af2\loch\f1             /* update parent */
\par \hich\af1\dbch\af2\loch\f1             if (i == 0) \{
\par \hich\af1\dbch\af2\loch\f1            \hich\af1\dbch\af2\loch\f1      childLT(pkey) = tmp[i]->adr;
\par \hich\af1\dbch\af2\loch\f1             \} else \{
\par \hich\af1\dbch\af2\loch\f1                 memcpy(pkey, gkey, ks(1));
\par \hich\af1\dbch\af2\loch\f1                 childGE(pkey) = tmp[i]->adr;
\par \hich\af1\dbch\af2\loch\f1                 pkey += ks(1);
\par \hich\af1\dbch\af2\loch\f1             \}
\par \hich\af1\dbch\af2\loch\f1         \} else \{
\par \hich\af1\dbch\af2\loch\f1             if (i == 0) \{
\par \hich\af1\dbch\af2\loch\f1                 /* update\hich\af1\dbch\af2\loch\f1  LT, tmp[0] */
\par \hich\af1\dbch\af2\loch\f1                 childLT(fkey(tmp[i])) = childLT(gkey);
\par \hich\af1\dbch\af2\loch\f1                 /* update LT, parent */
\par \hich\af1\dbch\af2\loch\f1                 childLT(pkey) = tmp[i]->adr;
\par \hich\af1\dbch\af2\loch\f1             \} else \{
\par \hich\af1\dbch\af2\loch\f1                 /* update LT, tmp[i] */
\par \hich\af1\dbch\af2\loch\f1                 childLT(fkey(tmp[i])) = \hich\af1\dbch\af2\loch\f1 childGE(gkey);
\par \hich\af1\dbch\af2\loch\f1                 /* update parent key */
\par \hich\af1\dbch\af2\loch\f1                 memcpy(pkey, gkey, ks(1));
\par \hich\af1\dbch\af2\loch\f1                 childGE(pkey) = tmp[i]->adr;
\par \hich\af1\dbch\af2\loch\f1                 gkey += ks(1);
\par \hich\af1\dbch\af2\loch\f1                 pkey += ks(1);
\par \hich\af1\dbch\af2\loch\f1                 ct(tmp[i])--;
\par \hich\af1\dbch\af2\loch\f1             \}
\par \hich\af1\dbch\af2\loch\f1        \hich\af1\dbch\af2\loch\f1  \}
\par 
\par \hich\af1\dbch\af2\loch\f1         /* install keys, tmp[i] */
\par \hich\af1\dbch\af2\loch\f1         memcpy(fkey(tmp[i]), gkey, ks(ct(tmp[i])));
\par \hich\af1\dbch\af2\loch\f1         leaf(tmp[i]) = leaf(gbuf);
\par 
\par \hich\af1\dbch\af2\loch\f1         gkey += ks(ct(tmp[i]));
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     leaf(pbuf) = false;
\par 
\par \hich\af1\dbch\af2\loch\f1    /************************
\par \hich\af1\dbch\af2\loch\f1     * write modified nodes *
\par \hich\af1\dbch\af2\loch\f1     ****\hich\af1\dbch\af2\loch\f1 ********************/
\par \hich\af1\dbch\af2\loch\f1     if ((rc = writeDisk(pbuf)) != 0) return rc;
\par \hich\af1\dbch\af2\loch\f1     for (i = 0; i < iu; i++)
\par \hich\af1\dbch\af2\loch\f1         if ((rc = writeDisk(tmp[i])) != 0) return rc;
\par 
\par \hich\af1\dbch\af2\loch\f1     return bErrOk;
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 static bErrType gatherRoot(void) \{
\par \hich\af1\dbch\af2\loch\f1     bufType *gbuf;
\par \hich\af1\dbch\af2\loch\f1     bufType *root;
\par 
\par \hich\af1\dbch\af2\loch\f1     /*\hich\af1\dbch\af2\loch\f1  gather root to gbuf */
\par \hich\af1\dbch\af2\loch\f1     root = &h->root;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang1031\langfe1040\langnp1031 \hich\af1\dbch\af2\loch\f1 gbuf = &h->gbuf;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 memcpy(p(gbuf), root->p, 3 * h->sectorSize);
\par \hich\af1\dbch\af2\loch\f1     leaf(gbuf) = leaf(root);
\par \hich\af1\dbch\af2\loch\f1     ct(root) = 0;
\par \hich\af1\dbch\af2\loch\f1     return bErrOk;
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 static bErrType gather(bufType *pbuf, keyType **pkey, bufType **tmp) \{
\par \hich\af1\dbch\af2\loch\f1  \hich\af1\dbch\af2\loch\f1    bErrType rc;                /* return code */
\par \hich\af1\dbch\af2\loch\f1     bufType *gbuf;
\par \hich\af1\dbch\af2\loch\f1     keyType *gkey;
\par 
\par \hich\af1\dbch\af2\loch\f1     /*
\par \hich\af1\dbch\af2\loch\f1      * input:
\par \hich\af1\dbch\af2\loch\f1      *   pbuf                   parent buffer
\par \hich\af1\dbch\af2\loch\f1      *   pkey                   pointer to match key in parent
\par \hich\af1\dbch\af2\loch\f1      * output:
\par \hich\af1\dbch\af2\loch\f1      *   tmp           \hich\af1\dbch\af2\loch\f1          buffers to use for scatter
\par \hich\af1\dbch\af2\loch\f1      *   pkey                   pointer to match key in parent
\par \hich\af1\dbch\af2\loch\f1      * returns:
\par \hich\af1\dbch\af2\loch\f1      *   bErrOk                 operation successful
\par \hich\af1\dbch\af2\loch\f1      * notes:
\par \hich\af1\dbch\af2\loch\f1      *   Gather 3 buffers to gbuf.  Setup for subsequent scatter by
\par \hich\af1\dbch\af2\loch\f1      *\hich\af1\dbch\af2\loch\f1    doing the following:
\par \hich\af1\dbch\af2\loch\f1      *     - setup tmp buffer array for scattered buffers
\par \hich\af1\dbch\af2\loch\f1      *     - adjust pkey to point to first key of 3 buffers
\par \hich\af1\dbch\af2\loch\f1      */
\par 
\par \hich\af1\dbch\af2\loch\f1     /* find 3 adjacent buffers */
\par \hich\af1\dbch\af2\loch\f1     if (*pkey == lkey(pbuf))
\par \hich\af1\dbch\af2\loch\f1         *pkey -= ks(1);
\par \hich\af1\dbch\af2\loch\f1     if ((rc = read\hich\af1\dbch\af2\loch\f1 Disk(childLT(*pkey), &tmp[0])) != 0) return rc;
\par \hich\af1\dbch\af2\loch\f1     if ((rc = readDisk(childGE(*pkey), &tmp[1])) != 0) return rc;
\par \hich\af1\dbch\af2\loch\f1     if ((rc = readDisk(childGE(*pkey + ks(1)), &tmp[2])) != 0) return rc;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* gather nodes to gbuf */
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang1031\langfe1040\langnp1031 \hich\af1\dbch\af2\loch\f1 gbuf = &h->gbuf;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 gkey = fkey\hich\af1\dbch\af2\loch\f1 (gbuf);
\par 
\par \hich\af1\dbch\af2\loch\f1     /* tmp[0] */
\par \hich\af1\dbch\af2\loch\f1     childLT(gkey) = childLT(fkey(tmp[0]));
\par \hich\af1\dbch\af2\loch\f1     memcpy(gkey, fkey(tmp[0]), ks(ct(tmp[0])));
\par \hich\af1\dbch\af2\loch\f1     gkey += ks(ct(tmp[0]));
\par \hich\af1\dbch\af2\loch\f1     ct(gbuf) = ct(tmp[0]);
\par 
\par \hich\af1\dbch\af2\loch\f1     /* tmp[1] */
\par \hich\af1\dbch\af2\loch\f1     if (!leaf(tmp[1])) \{
\par \hich\af1\dbch\af2\loch\f1         memcpy(gkey, *pkey, ks(1));
\par \hich\af1\dbch\af2\loch\f1      \hich\af1\dbch\af2\loch\f1    childGE(gkey) = childLT(fkey(tmp[1]));
\par \hich\af1\dbch\af2\loch\f1         ct(gbuf)++;
\par \hich\af1\dbch\af2\loch\f1         gkey += ks(1);
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     memcpy(gkey, fkey(tmp[1]), ks(ct(tmp[1])));
\par \hich\af1\dbch\af2\loch\f1     gkey += ks(ct(tmp[1]));
\par \hich\af1\dbch\af2\loch\f1     ct(gbuf) += ct(tmp[1]);
\par 
\par \hich\af1\dbch\af2\loch\f1     /* tmp[2] */
\par \hich\af1\dbch\af2\loch\f1     if (!leaf(tmp[2])) \{
\par \hich\af1\dbch\af2\loch\f1         memcpy(gke\hich\af1\dbch\af2\loch\f1 y, *pkey+ks(1), ks(1));
\par \hich\af1\dbch\af2\loch\f1         childGE(gkey) = childLT(fkey(tmp[2]));
\par \hich\af1\dbch\af2\loch\f1         ct(gbuf)++;
\par \hich\af1\dbch\af2\loch\f1         gkey += ks(1);
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     memcpy(gkey, fkey(tmp[2]), ks(ct(tmp[2])));
\par \hich\af1\dbch\af2\loch\f1     ct(gbuf) += ct(tmp[2]);
\par 
\par \hich\af1\dbch\af2\loch\f1     leaf(gbuf) = leaf(tmp[0]);
\par 
\par \hich\af1\dbch\af2\loch\f1     return bErrOk;
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 bErrT\hich\af1\dbch\af2\loch\f1 ype bOpen(bOpenType info, bHandleType *handle) \{
\par \hich\af1\dbch\af2\loch\f1     bErrType rc;                /* return code */
\par \hich\af1\dbch\af2\loch\f1     int bufCt;                  /* number of tmp buffers */
\par \hich\af1\dbch\af2\loch\f1     bufType *buf;               /* buffer */
\par \hich\af1\dbch\af2\loch\f1     int maxCt;                  /* maximum number of\hich\af1\dbch\af2\loch\f1  keys in a node */
\par \hich\af1\dbch\af2\loch\f1     bufType *root;
\par \hich\af1\dbch\af2\loch\f1     int i;
\par \hich\af1\dbch\af2\loch\f1     nodeType *p;
\par 
\par \hich\af1\dbch\af2\loch\f1     if ((info.sectorSize < sizeof(hNode)) || (info.sectorSize % 4))
\par \hich\af1\dbch\af2\loch\f1         return bErrSectorSize;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* determine sizes and offsets */
\par \hich\af1\dbch\af2\loch\f1     /* leaf/n, prev, next, [childLT,key,rec]... chi\hich\af1\dbch\af2\loch\f1 ldGE */
\par \hich\af1\dbch\af2\loch\f1     /* ensure that there are at least 3 children/parent for gather/scatter */
\par \hich\af1\dbch\af2\loch\f1     maxCt = info.sectorSize - (sizeof(nodeType) - sizeof(keyType));
\par \hich\af1\dbch\af2\loch\f1     maxCt /= sizeof(bAdrType) + info.keySize + sizeof(eAdrType);
\par \hich\af1\dbch\af2\loch\f1     if (maxCt < 6) return bErrSectorS\hich\af1\dbch\af2\loch\f1 ize;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* copy parms to hNode */
\par \hich\af1\dbch\af2\loch\f1     if ((h = malloc(sizeof(hNode))) == NULL) return error(bErrMemory);
\par \hich\af1\dbch\af2\loch\f1     memset(h, 0, sizeof(hNode));
\par \hich\af1\dbch\af2\loch\f1     h->keySize = info.keySize;
\par \hich\af1\dbch\af2\loch\f1     h->sectorSize = info.sectorSize;
\par \hich\af1\dbch\af2\loch\f1     h->comp = info.comp;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* childLT, key, r\hich\af1\dbch\af2\loch\f1 ec */
\par \hich\af1\dbch\af2\loch\f1     h->ks = sizeof(bAdrType) + h->keySize + sizeof(eAdrType);
\par \hich\af1\dbch\af2\loch\f1     h->maxCt = maxCt;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* Allocate buflist.
\par \hich\af1\dbch\af2\loch\f1      * During insert/delete, need simultaneous access to 7 buffers:
\par \hich\af1\dbch\af2\loch\f1      *  - 4 adjacent child bufs
\par \hich\af1\dbch\af2\loch\f1      *  - 1 parent buf
\par \hich\af1\dbch\af2\loch\f1      *  - 1 next \hich\af1\dbch\af2\loch\f1 sequential link
\par \hich\af1\dbch\af2\loch\f1      *  - 1 lastGE
\par \hich\af1\dbch\af2\loch\f1      */
\par \hich\af1\dbch\af2\loch\f1     bufCt = 7;
\par \hich\af1\dbch\af2\loch\f1     if ((h->malloc1 = malloc(bufCt * sizeof(bufType))) == NULL) 
\par \hich\af1\dbch\af2\loch\f1         return error(bErrMemory);
\par \hich\af1\dbch\af2\loch\f1     buf = h->malloc1;
\par 
\par \hich\af1\dbch\af2\loch\f1     /*
\par \hich\af1\dbch\af2\loch\f1      * Allocate bufs.
\par \hich\af1\dbch\af2\loch\f1      * We need space for the following:
\par \hich\af1\dbch\af2\loch\f1      * \hich\af1\dbch\af2\loch\f1  - bufCt buffers, of size sectorSize
\par \hich\af1\dbch\af2\loch\f1      *  - 1 buffer for root, of size 3*sectorSize
\par \hich\af1\dbch\af2\loch\f1      *  - 1 buffer for gbuf, size 3*sectorsize + 2 extra keys
\par \hich\af1\dbch\af2\loch\f1      *    to allow for LT pointers in last 2 nodes when gathering 3 full nodes
\par \hich\af1\dbch\af2\loch\f1      */
\par \hich\af1\dbch\af2\loch\f1     if ((h->malloc2 \hich\af1\dbch\af2\loch\f1 = malloc((bufCt+6) * h->sectorSize + 2 * h->ks)) == NULL) 
\par \hich\af1\dbch\af2\loch\f1         return error(bErrMemory);
\par \hich\af1\dbch\af2\loch\f1     p = h->malloc2;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* initialize buflist */
\par \hich\af1\dbch\af2\loch\f1     h->bufList.next = buf;
\par \hich\af1\dbch\af2\loch\f1     h->bufList.prev = buf + (bufCt - 1);
\par \hich\af1\dbch\af2\loch\f1     for (i = 0; i < bufCt; i++) \{
\par \hich\af1\dbch\af2\loch\f1         buf\hich\af1\dbch\af2\loch\f1 ->next = buf + 1;
\par \hich\af1\dbch\af2\loch\f1         buf->prev = buf - 1;
\par \hich\af1\dbch\af2\loch\f1         buf->modified = false;
\par \hich\af1\dbch\af2\loch\f1         buf->valid = false;
\par \hich\af1\dbch\af2\loch\f1         }{\f1\lang1031\langfe1040\langnp1031 \hich\af1\dbch\af2\loch\f1 buf->p = p;
\par \hich\af1\dbch\af2\loch\f1         }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 p = (nodeType *)((char *)p + h->sectorSize);
\par \hich\af1\dbch\af2\loch\f1         buf++;
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     h->bufList.next->prev = &h->bufList;
\par \hich\af1\dbch\af2\loch\f1     h->bufList.\hich\af1\dbch\af2\loch\f1 prev->next = &h->bufList;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* initialize root */
\par \hich\af1\dbch\af2\loch\f1     root = &h->root;
\par \hich\af1\dbch\af2\loch\f1     root->p = p;
\par \hich\af1\dbch\af2\loch\f1     p = (nodeType *)((char *)p + 3*h->sectorSize);
\par \hich\af1\dbch\af2\loch\f1     h->gbuf.p = p;      /* done last to include extra 2 keys */
\par 
\par \hich\af1\dbch\af2\loch\f1     h->curBuf = NULL;
\par \hich\af1\dbch\af2\loch\f1     h->curKey = NULL;
\par 
\par \hich\af1\dbch\af2\loch\f1     \hich\af1\dbch\af2\loch\f1 /* initialize root */
\par \hich\af1\dbch\af2\loch\f1     if ((h->fp = fopen(info.iName, "r+b")) != NULL) \{
\par \hich\af1\dbch\af2\loch\f1         /* open an existing database */
\par \hich\af1\dbch\af2\loch\f1         if ((rc = readDisk(0, &root)) != 0) return rc;
\par \hich\af1\dbch\af2\loch\f1         if (fseek(h->fp, 0, SEEK_END)) return error(bErrIO);
\par \hich\af1\dbch\af2\loch\f1         if ((h->nextFree\hich\af1\dbch\af2\loch\f1 Adr = ftell(h->fp)) == -1) return error(bErrIO);
\par \hich\af1\dbch\af2\loch\f1     \} else if ((h->fp = fopen(info.iName, "w+b")) != NULL) \{
\par \hich\af1\dbch\af2\loch\f1         /* initialize root */
\par \hich\af1\dbch\af2\loch\f1         memset(root->p, 0, 3*h->sectorSize);
\par \hich\af1\dbch\af2\loch\f1         leaf(root) = 1;
\par \hich\af1\dbch\af2\loch\f1         h->nextFreeAdr = 3 * h->sectorSize;
\par \hich\af1\dbch\af2\loch\f1    \hich\af1\dbch\af2\loch\f1  \} else \{
\par \hich\af1\dbch\af2\loch\f1         /* something's wrong */
\par \hich\af1\dbch\af2\loch\f1         free(h);
\par \hich\af1\dbch\af2\loch\f1         return bErrFileNotOpen;
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     /* append node to hList */
\par \hich\af1\dbch\af2\loch\f1     if (hList.next) \{
\par \hich\af1\dbch\af2\loch\f1         h->prev = hList.next;
\par \hich\af1\dbch\af2\loch\f1         h->next = &hList;
\par \hich\af1\dbch\af2\loch\f1         h->prev->next = h;
\par \hich\af1\dbch\af2\loch\f1         h->next->prev \hich\af1\dbch\af2\loch\f1 = h;
\par \hich\af1\dbch\af2\loch\f1     \} else \{
\par \hich\af1\dbch\af2\loch\f1         /* first item in hList */
\par \hich\af1\dbch\af2\loch\f1         h->prev = h->next = &hList;
\par \hich\af1\dbch\af2\loch\f1         hList.next = hList.prev = h;
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     *handle = h;
\par \hich\af1\dbch\af2\loch\f1     return bErrOk;
\par \}
\par 
\par 
\par \hich\af1\dbch\af2\loch\f1 bErrType bClose(bHandleType handle) \{
\par \hich\af1\dbch\af2\loch\f1     h = handle;
\par \hich\af1\dbch\af2\loch\f1     if (h == NULL) return bErr\hich\af1\dbch\af2\loch\f1 Ok;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* remove from list */
\par \hich\af1\dbch\af2\loch\f1     if (h->next) \{
\par \hich\af1\dbch\af2\loch\f1         h->next->prev = h->prev;
\par \hich\af1\dbch\af2\loch\f1         h->prev->next = h->next;
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     /* flush idx */
\par \hich\af1\dbch\af2\loch\f1     if (h->fp) \{
\par \hich\af1\dbch\af2\loch\f1         flushAll();
\par \hich\af1\dbch\af2\loch\f1         fclose(h->fp);
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     if (h->malloc2) free(h->malloc2);
\par \hich\af1\dbch\af2\loch\f1     if \hich\af1\dbch\af2\loch\f1 (h->malloc1) free(h->malloc1);
\par \hich\af1\dbch\af2\loch\f1     free(h);
\par \hich\af1\dbch\af2\loch\f1     return bErrOk;
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 bErrType bFindKey(bHandleType handle, void *key, eAdrType *rec) \{
\par \hich\af1\dbch\af2\loch\f1     keyType *mkey;              /* matched key */
\par \hich\af1\dbch\af2\loch\f1     bufType *buf;               /* buffer */
\par \hich\af1\dbch\af2\loch\f1     bErrType rc;             \hich\af1\dbch\af2\loch\f1    /* return code */
\par 
\par \hich\af1\dbch\af2\loch\f1     h = handle;
\par \hich\af1\dbch\af2\loch\f1     buf = &h->root;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* find key, and return address */
\par \hich\af1\dbch\af2\loch\f1     while (1) \{
\par \hich\af1\dbch\af2\loch\f1         if (leaf(buf)) \{
\par \hich\af1\dbch\af2\loch\f1             if (search(buf, key, &mkey, MODE_FIRST) == 0) \{
\par \hich\af1\dbch\af2\loch\f1                 *rec = rec(mkey);
\par \hich\af1\dbch\af2\loch\f1                 h->curB\hich\af1\dbch\af2\loch\f1 uf = buf; h->curKey = mkey;
\par \hich\af1\dbch\af2\loch\f1                 return bErrOk;
\par \hich\af1\dbch\af2\loch\f1             \} else \{
\par \hich\af1\dbch\af2\loch\f1                 return bErrKeyNotFound;
\par \hich\af1\dbch\af2\loch\f1             \}
\par \hich\af1\dbch\af2\loch\f1         \} else \{
\par \hich\af1\dbch\af2\loch\f1             if (search(buf, key, &mkey, MODE_FIRST) < 0) \{
\par \hich\af1\dbch\af2\loch\f1                 if ((rc = readDisk(childLT(mke\hich\af1\dbch\af2\loch\f1 y), &buf)) != 0) return rc;
\par \hich\af1\dbch\af2\loch\f1             \} else \{
\par \hich\af1\dbch\af2\loch\f1                 if ((rc = readDisk(childGE(mkey), &buf)) != 0) return rc;
\par \hich\af1\dbch\af2\loch\f1             \}
\par \hich\af1\dbch\af2\loch\f1         \}
\par \hich\af1\dbch\af2\loch\f1     \}
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 bErrType bInsertKey(bHandleType handle, void *key, eAdrType rec) \{
\par \hich\af1\dbch\af2\loch\f1     int rc;                     /\hich\af1\dbch\af2\loch\f1 * return code */
\par \hich\af1\dbch\af2\loch\f1     keyType *mkey;              /* match key */
\par \hich\af1\dbch\af2\loch\f1     int len;                    /* length to shift */
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 int cc;                     /* condition code */
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 bufType *buf, *root;
\par \hich\af1\dbch\af2\loch\f1     bufType *tmp[4];
\par \hich\af1\dbch\af2\loch\f1     unsigned int keyOff;
\par \hich\af1\dbch\af2\loch\f1     bool last\hich\af1\dbch\af2\loch\f1 GEvalid;           /* true if GE branch taken */
\par \hich\af1\dbch\af2\loch\f1     bool lastLTvalid;           /* true if LT branch taken after GE branch */
\par \hich\af1\dbch\af2\loch\f1     bAdrType lastGE;            /* last childGE traversed */
\par \hich\af1\dbch\af2\loch\f1     unsigned int lastGEkey;     /* last childGE key traversed */
\par \hich\af1\dbch\af2\loch\f1    \hich\af1\dbch\af2\loch\f1  int height;                 /* height of tree */
\par 
\par \hich\af1\dbch\af2\loch\f1     h = handle;
\par \hich\af1\dbch\af2\loch\f1     root = &h->root;
\par \hich\af1\dbch\af2\loch\f1     lastGEvalid = false;
\par \hich\af1\dbch\af2\loch\f1     lastLTvalid = false;
\par 
\par \hich\af1\dbch\af2\loch\f1     /* check for full root */
\par \hich\af1\dbch\af2\loch\f1     if (ct(root) == 3 * h->maxCt) \{
\par \hich\af1\dbch\af2\loch\f1         /* gather root and scatter to 4 bufs */
\par \hich\af1\dbch\af2\loch\f1    \hich\af1\dbch\af2\loch\f1      /* this increases b-tree height by 1 */
\par \hich\af1\dbch\af2\loch\f1         if ((rc = gatherRoot()) != 0) return rc;
\par \hich\af1\dbch\af2\loch\f1         if ((rc = scatter(root, fkey(root), 0, tmp)) != 0) return rc;
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     buf = root;
\par \hich\af1\dbch\af2\loch\f1     height = 0;
\par \hich\af1\dbch\af2\loch\f1     while(1) \{
\par \hich\af1\dbch\af2\loch\f1         if (leaf(buf)) \{
\par \hich\af1\dbch\af2\loch\f1             /*\hich\af1\dbch\af2\loch\f1  in leaf, and there' room guaranteed */
\par 
\par \hich\af1\dbch\af2\loch\f1             if (height > maxHeight) maxHeight = height;
\par 
\par \hich\af1\dbch\af2\loch\f1             /* set mkey to point to insertion point */
\par \hich\af1\dbch\af2\loch\f1             switch(search(buf, key, &mkey, MODE_MATCH)) \{
\par \hich\af1\dbch\af2\loch\f1             case CC_LT:  /* key < mkey */
\par \hich\af1\dbch\af2\loch\f1    \hich\af1\dbch\af2\loch\f1              if (h->comp(key, mkey) == CC_EQ)
\par \hich\af1\dbch\af2\loch\f1                     return bErrDupKeys;
\par \hich\af1\dbch\af2\loch\f1                 break;
\par \hich\af1\dbch\af2\loch\f1             case CC_EQ:  /* key = mkey */
\par \hich\af1\dbch\af2\loch\f1                 return bErrDupKeys;
\par \hich\af1\dbch\af2\loch\f1                 break;
\par \hich\af1\dbch\af2\loch\f1             case CC_GT:  /* key > mkey */
\par \hich\af1\dbch\af2\loch\f1     \hich\af1\dbch\af2\loch\f1             if (h->comp(key, mkey) == CC_EQ)
\par \hich\af1\dbch\af2\loch\f1                     return bErrDupKeys;
\par \hich\af1\dbch\af2\loch\f1                 mkey += ks(1);
\par \hich\af1\dbch\af2\loch\f1                 break;
\par \hich\af1\dbch\af2\loch\f1             \}
\par 
\par \hich\af1\dbch\af2\loch\f1             /* shift items GE key to right */
\par \hich\af1\dbch\af2\loch\f1             keyOff = mkey - fkey(buf);
\par \hich\af1\dbch\af2\loch\f1             len =\hich\af1\dbch\af2\loch\f1  ks(ct(buf)) - keyOff;
\par \hich\af1\dbch\af2\loch\f1             if (len) memmove(mkey + ks(1), mkey, len);
\par 
\par \hich\af1\dbch\af2\loch\f1             /* insert new key */
\par \hich\af1\dbch\af2\loch\f1             memcpy(key(mkey), key, h->keySize);
\par \hich\af1\dbch\af2\loch\f1             rec(mkey) = rec;
\par \hich\af1\dbch\af2\loch\f1             childGE(mkey) = 0;
\par \hich\af1\dbch\af2\loch\f1             ct(buf)++;
\par \hich\af1\dbch\af2\loch\f1             i\hich\af1\dbch\af2\loch\f1 f ((rc = writeDisk(buf)) != 0) return rc;
\par 
\par \hich\af1\dbch\af2\loch\f1             /* if new key is first key, then fixup lastGE key */
\par \hich\af1\dbch\af2\loch\f1             if (!keyOff && lastLTvalid) \{
\par \hich\af1\dbch\af2\loch\f1                 bufType *tbuf;
\par \hich\af1\dbch\af2\loch\f1                 keyType *tkey;
\par \hich\af1\dbch\af2\loch\f1                 if ((rc = readDisk(lastGE, &\hich\af1\dbch\af2\loch\f1 tbuf)) != 0) return rc;
\par \hich\af1\dbch\af2\loch\f1                 tkey = fkey(tbuf) + lastGEkey;
\par \hich\af1\dbch\af2\loch\f1                 memcpy(key(tkey), key, h->keySize);
\par \hich\af1\dbch\af2\loch\f1                 rec(tkey) = rec;
\par \hich\af1\dbch\af2\loch\f1                 if ((rc = writeDisk(tbuf)) != 0) return rc;
\par \hich\af1\dbch\af2\loch\f1             \}
\par \hich\af1\dbch\af2\loch\f1             nKeysIns++;
\par \hich\af1\dbch\af2\loch\f1   \hich\af1\dbch\af2\loch\f1           break;
\par \hich\af1\dbch\af2\loch\f1         \} else \{
\par \hich\af1\dbch\af2\loch\f1             /* internal node, descend to child */
\par \hich\af1\dbch\af2\loch\f1             bufType *cbuf;      /* child buf */
\par 
\par \hich\af1\dbch\af2\loch\f1             height++;
\par \hich\af1\dbch\af2\loch\f1           
\par \hich\af1\dbch\af2\loch\f1             /* read child */
\par \hich\af1\dbch\af2\loch\f1             if ((cc = search(buf, key, &mkey, MODE_MATCH)) < \hich\af1\dbch\af2\loch\f1 0) \{
\par \hich\af1\dbch\af2\loch\f1                 if ((rc = readDisk(childLT(mkey), &cbuf)) != 0) return rc;
\par \hich\af1\dbch\af2\loch\f1             \} else \{
\par \hich\af1\dbch\af2\loch\f1                 if ((rc = readDisk(childGE(mkey), &cbuf)) != 0) return rc;
\par \hich\af1\dbch\af2\loch\f1             \}
\par 
\par \hich\af1\dbch\af2\loch\f1             /* check for room in child */
\par \hich\af1\dbch\af2\loch\f1             if (ct(cbuf\hich\af1\dbch\af2\loch\f1 ) == h->maxCt) \{
\par 
\par \hich\af1\dbch\af2\loch\f1                 /* gather 3 bufs and scatter */
\par \hich\af1\dbch\af2\loch\f1                 if ((rc = gather(buf, &mkey, tmp)) != 0) return rc;
\par \hich\af1\dbch\af2\loch\f1                 if ((rc = scatter(buf, mkey, 3, tmp)) != 0) return rc;
\par 
\par \hich\af1\dbch\af2\loch\f1                 /* read child */
\par \hich\af1\dbch\af2\loch\f1                 i\hich\af1\dbch\af2\loch\f1 f ((cc = search(buf, key, &mkey, MODE_MATCH)) < 0) \{
\par \hich\af1\dbch\af2\loch\f1                     if ((rc = readDisk(childLT(mkey), &cbuf)) != 0) return rc;
\par \hich\af1\dbch\af2\loch\f1                 \} else \{
\par \hich\af1\dbch\af2\loch\f1                     if ((rc = readDisk(childGE(mkey), &cbuf)) != 0) return rc;
\par \hich\af1\dbch\af2\loch\f1                 \}
\par \hich\af1\dbch\af2\loch\f1   \hich\af1\dbch\af2\loch\f1           \}
\par \hich\af1\dbch\af2\loch\f1             if (cc >= 0 || mkey != fkey(buf)) \{
\par \hich\af1\dbch\af2\loch\f1                 lastGEvalid = true;
\par \hich\af1\dbch\af2\loch\f1                 lastLTvalid = false;
\par \hich\af1\dbch\af2\loch\f1                 }{\f1\lang1031\langfe1040\langnp1031 \hich\af1\dbch\af2\loch\f1 lastGE = buf->adr;
\par \hich\af1\dbch\af2\loch\f1                 }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 lastGEkey = mkey - fkey(buf);
\par \hich\af1\dbch\af2\loch\f1                 if (cc < 0) lastGEkey -= k\hich\af1\dbch\af2\loch\f1 s(1);
\par \hich\af1\dbch\af2\loch\f1             \} else \{
\par \hich\af1\dbch\af2\loch\f1                 if (lastGEvalid) lastLTvalid = true;
\par \hich\af1\dbch\af2\loch\f1             \}
\par \hich\af1\dbch\af2\loch\f1             buf = cbuf;
\par \hich\af1\dbch\af2\loch\f1         \}
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     return bErrOk;
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 bErrType bDeleteKey(bHandleType handle, void *key) \{
\par \hich\af1\dbch\af2\loch\f1     int rc;                     /* return code\hich\af1\dbch\af2\loch\f1  */
\par \hich\af1\dbch\af2\loch\f1     keyType *mkey;              /* match key */
\par \hich\af1\dbch\af2\loch\f1     int len;                    /* length to shift */
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang1036\langfe1040\langnp1036 \hich\af1\dbch\af2\loch\f1 int cc;                     /* condition code */
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 bufType *buf;               /* buffer */
\par \hich\af1\dbch\af2\loch\f1     bufType *tmp[4];
\par \hich\af1\dbch\af2\loch\f1     unsigned int keyOff;
\par \hich\af1\dbch\af2\loch\f1     bo\hich\af1\dbch\af2\loch\f1 ol lastGEvalid;           /* true if GE branch taken */
\par \hich\af1\dbch\af2\loch\f1     bool lastLTvalid;           /* true if LT branch taken after GE branch */
\par \hich\af1\dbch\af2\loch\f1     bAdrType lastGE;            /* last childGE traversed */
\par \hich\af1\dbch\af2\loch\f1     unsigned int lastGEkey;     /* last childGE key traversed\hich\af1\dbch\af2\loch\f1  */
\par \hich\af1\dbch\af2\loch\f1     bufType *root;
\par \hich\af1\dbch\af2\loch\f1     bufType *gbuf;
\par 
\par \hich\af1\dbch\af2\loch\f1     h = handle;
\par \hich\af1\dbch\af2\loch\f1     root = &h->root;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang1031\langfe1040\langnp1031 \hich\af1\dbch\af2\loch\f1 gbuf = &h->gbuf;
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 lastGEvalid = false;
\par \hich\af1\dbch\af2\loch\f1     lastLTvalid = false;
\par 
\par \hich\af1\dbch\af2\loch\f1     buf = root;
\par \hich\af1\dbch\af2\loch\f1     while(1) \{
\par \hich\af1\dbch\af2\loch\f1         if (leaf(buf)) \{
\par 
\par \hich\af1\dbch\af2\loch\f1             /* set mkey to point to deletion po\hich\af1\dbch\af2\loch\f1 int */
\par \hich\af1\dbch\af2\loch\f1             if (search(buf, key, &mkey, MODE_MATCH) != 0)
\par \hich\af1\dbch\af2\loch\f1                 return bErrKeyNotFound;
\par 
\par \hich\af1\dbch\af2\loch\f1             /* shift items GT key to left */
\par \hich\af1\dbch\af2\loch\f1             keyOff = mkey - fkey(buf);
\par \hich\af1\dbch\af2\loch\f1             len = ks(ct(buf)-1) - keyOff;
\par \hich\af1\dbch\af2\loch\f1             if (len) mem\hich\af1\dbch\af2\loch\f1 move(mkey, mkey + ks(1), len);
\par \hich\af1\dbch\af2\loch\f1             ct(buf)--;
\par \hich\af1\dbch\af2\loch\f1             if ((rc = writeDisk(buf)) != 0) return rc;
\par 
\par \hich\af1\dbch\af2\loch\f1             /* if deleted key is first key, then fixup lastGE key */
\par \hich\af1\dbch\af2\loch\f1             if (!keyOff && lastLTvalid) \{
\par \hich\af1\dbch\af2\loch\f1                 bufType *tbuf;
\par \hich\af1\dbch\af2\loch\f1     \hich\af1\dbch\af2\loch\f1             keyType *tkey;
\par \hich\af1\dbch\af2\loch\f1                 if ((rc = readDisk(lastGE, &tbuf)) != 0) return rc;
\par \hich\af1\dbch\af2\loch\f1                 tkey = fkey(tbuf) + lastGEkey;
\par \hich\af1\dbch\af2\loch\f1                 memcpy(key(tkey), mkey, h->keySize);
\par \hich\af1\dbch\af2\loch\f1                 rec(tkey) = rec(mkey);
\par \hich\af1\dbch\af2\loch\f1                 if ((r\hich\af1\dbch\af2\loch\f1 c = writeDisk(tbuf)) != 0) return rc;
\par \hich\af1\dbch\af2\loch\f1             \}
\par \hich\af1\dbch\af2\loch\f1             nKeysDel++;
\par \hich\af1\dbch\af2\loch\f1             break;
\par \hich\af1\dbch\af2\loch\f1         \} else \{
\par \hich\af1\dbch\af2\loch\f1             /* internal node, descend to child */
\par \hich\af1\dbch\af2\loch\f1             bufType *cbuf;      /* child buf */
\par \hich\af1\dbch\af2\loch\f1           
\par \hich\af1\dbch\af2\loch\f1             /* read child */
\par \hich\af1\dbch\af2\loch\f1       \hich\af1\dbch\af2\loch\f1       if ((cc = search(buf, key, &mkey, MODE_MATCH)) < 0) \{
\par \hich\af1\dbch\af2\loch\f1                 if ((rc = readDisk(childLT(mkey), &cbuf)) != 0) return rc;
\par \hich\af1\dbch\af2\loch\f1             \} else \{
\par \hich\af1\dbch\af2\loch\f1                 if ((rc = readDisk(childGE(mkey), &cbuf)) != 0) return rc;
\par \hich\af1\dbch\af2\loch\f1             \}
\par 
\par \hich\af1\dbch\af2\loch\f1           \hich\af1\dbch\af2\loch\f1   /* check for room to delete */
\par \hich\af1\dbch\af2\loch\f1             if (ct(cbuf) == h->maxCt/2) \{
\par 
\par \hich\af1\dbch\af2\loch\f1                 /* gather 3 bufs and scatter */
\par \hich\af1\dbch\af2\loch\f1                 if ((rc = gather(buf, &mkey, tmp)) != 0) return rc;
\par 
\par \hich\af1\dbch\af2\loch\f1                 /* if last 3 bufs in root, and count is low eno\hich\af1\dbch\af2\loch\f1 ugh... */
\par \hich\af1\dbch\af2\loch\f1                 if (buf == root
\par \hich\af1\dbch\af2\loch\f1                 && ct(root) == 2 
\par \hich\af1\dbch\af2\loch\f1                 && ct(gbuf) < (3*(3*h->maxCt))/4) \{
\par \hich\af1\dbch\af2\loch\f1                     /* collapse tree by one level */
\par \hich\af1\dbch\af2\loch\f1                     }{\f1 \hich\af1\dbch\af2\loch\f1 scatterRoot();
\par \hich\af1\dbch\af2\loch\f1                     nNodesDel += 3;
\par \hich\af1\dbch\af2\loch\f1     \hich\af1\dbch\af2\loch\f1                 continue;
\par \hich\af1\dbch\af2\loch\f1                 }{\f1\lang2057\langfe1040\langnp2057 \}
\par 
\par \hich\af1\dbch\af2\loch\f1                 if ((rc = scatter(buf, mkey, 3, tmp)) != 0) return rc;
\par 
\par \hich\af1\dbch\af2\loch\f1                 /* read child */
\par \hich\af1\dbch\af2\loch\f1                 if ((cc = search(buf, key, &mkey, MODE_MATCH)) < 0) \{
\par \hich\af1\dbch\af2\loch\f1                     if ((rc= readDis\hich\af1\dbch\af2\loch\f1 k(childLT(mkey), &cbuf)) != 0) return rc;
\par \hich\af1\dbch\af2\loch\f1                 \} else \{
\par \hich\af1\dbch\af2\loch\f1                     if ((rc= readDisk(childGE(mkey), &cbuf)) != 0) return rc;
\par \hich\af1\dbch\af2\loch\f1                 \}
\par \hich\af1\dbch\af2\loch\f1             \}
\par \hich\af1\dbch\af2\loch\f1             if (cc >= 0 || mkey != fkey(buf)) \{
\par \hich\af1\dbch\af2\loch\f1                 lastGEvalid = t\hich\af1\dbch\af2\loch\f1 rue;
\par \hich\af1\dbch\af2\loch\f1                 lastLTvalid = false;
\par \hich\af1\dbch\af2\loch\f1                 }{\f1\lang1031\langfe1040\langnp1031 \hich\af1\dbch\af2\loch\f1 lastGE = buf->adr;
\par \hich\af1\dbch\af2\loch\f1                 }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 lastGEkey = mkey - fkey(buf);
\par \hich\af1\dbch\af2\loch\f1                 if (cc < 0) lastGEkey -= ks(1);
\par \hich\af1\dbch\af2\loch\f1             \} else \{
\par \hich\af1\dbch\af2\loch\f1                 if (lastGEvalid) lastLTvalid = true;
\par \hich\af1\dbch\af2\loch\f1            \hich\af1\dbch\af2\loch\f1  \}
\par \hich\af1\dbch\af2\loch\f1             buf = cbuf;
\par \hich\af1\dbch\af2\loch\f1         \}
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     return bErrOk;
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 bErrType bFindFirstKey(bHandleType handle, void *key, eAdrType *rec) \{
\par \hich\af1\dbch\af2\loch\f1     bErrType rc;                /* return code */
\par \hich\af1\dbch\af2\loch\f1     bufType *buf;               /* buffer */
\par 
\par \hich\af1\dbch\af2\loch\f1     h = handle;
\par \hich\af1\dbch\af2\loch\f1     buf\hich\af1\dbch\af2\loch\f1  = &h->root;
\par \hich\af1\dbch\af2\loch\f1     while (!leaf(buf)) \{
\par \hich\af1\dbch\af2\loch\f1         if ((rc = readDisk(childLT(fkey(buf)), &buf)) != 0) return rc;
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     if (ct(buf) == 0) return bErrKeyNotFound;
\par \hich\af1\dbch\af2\loch\f1     memcpy(key, key(fkey(buf)), h->keySize);
\par \hich\af1\dbch\af2\loch\f1     *rec = rec(fkey(buf));
\par \hich\af1\dbch\af2\loch\f1     h->curBuf = buf; h-\hich\af1\dbch\af2\loch\f1 >curKey = fkey(buf);
\par \hich\af1\dbch\af2\loch\f1     return bErrOk;
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 bErrType bFindLastKey(bHandleType handle, void *key, eAdrType *rec) \{
\par \hich\af1\dbch\af2\loch\f1     bErrType rc;                /* return code */
\par \hich\af1\dbch\af2\loch\f1     bufType *buf;               /* buffer */
\par 
\par \hich\af1\dbch\af2\loch\f1     h = handle;
\par \hich\af1\dbch\af2\loch\f1     buf = &h->root;
\par \hich\af1\dbch\af2\loch\f1     while (\hich\af1\dbch\af2\loch\f1 !leaf(buf)) \{
\par \hich\af1\dbch\af2\loch\f1         if ((rc = readDisk(childGE(lkey(buf)), &buf)) != 0) return rc;
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     if (ct(buf) == 0) return bErrKeyNotFound;
\par \hich\af1\dbch\af2\loch\f1     memcpy(key, key(lkey(buf)), h->keySize);
\par \hich\af1\dbch\af2\loch\f1     *rec = rec(lkey(buf));
\par \hich\af1\dbch\af2\loch\f1     h->curBuf = buf; h->curKey = lkey(buf);
\par \hich\af1\dbch\af2\loch\f1    \hich\af1\dbch\af2\loch\f1  return bErrOk;
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 bErrType bFindNextKey(bHandleType handle, void *key, eAdrType *rec) \{
\par \hich\af1\dbch\af2\loch\f1     bErrType rc;                /* return code */
\par \hich\af1\dbch\af2\loch\f1     keyType *nkey;              /* next key */
\par \hich\af1\dbch\af2\loch\f1     bufType *buf;               /* buffer */
\par 
\par \hich\af1\dbch\af2\loch\f1     h = handle;
\par \hich\af1\dbch\af2\loch\f1     if (\hich\af1\dbch\af2\loch\f1 (buf = h->curBuf) == NULL) return bErrKeyNotFound;
\par \hich\af1\dbch\af2\loch\f1     if (h->curKey == lkey(buf)) \{
\par \hich\af1\dbch\af2\loch\f1         /* current key is last key in leaf node */
\par \hich\af1\dbch\af2\loch\f1         if (next(buf)) \{
\par \hich\af1\dbch\af2\loch\f1             /* fetch next set */
\par \hich\af1\dbch\af2\loch\f1             if ((rc = readDisk(next(buf), &buf)) != 0) return \hich\af1\dbch\af2\loch\f1 rc;
\par \hich\af1\dbch\af2\loch\f1             nkey = fkey(buf);
\par \hich\af1\dbch\af2\loch\f1         \} else \{
\par \hich\af1\dbch\af2\loch\f1             /* no more sets */
\par \hich\af1\dbch\af2\loch\f1             return bErrKeyNotFound;
\par \hich\af1\dbch\af2\loch\f1         \}
\par \hich\af1\dbch\af2\loch\f1     \} else \{
\par \hich\af1\dbch\af2\loch\f1         /* bump to next key */
\par \hich\af1\dbch\af2\loch\f1         nkey = h->curKey + ks(1);
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     memcpy(key, key(nkey), h->keySize);
\par \hich\af1\dbch\af2\loch\f1     \hich\af1\dbch\af2\loch\f1 *rec = rec(nkey);
\par \hich\af1\dbch\af2\loch\f1     h->curBuf = buf; h->curKey = nkey;
\par \hich\af1\dbch\af2\loch\f1     return bErrOk;
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 bErrType bFindPrevKey(bHandleType handle, void *key, eAdrType *rec) \{
\par \hich\af1\dbch\af2\loch\f1     bErrType rc;                /* return code */
\par \hich\af1\dbch\af2\loch\f1     keyType *pkey;              /* previous key */
\par \hich\af1\dbch\af2\loch\f1     ke\hich\af1\dbch\af2\loch\f1 yType *fkey;              /* first key */
\par \hich\af1\dbch\af2\loch\f1     bufType *buf;               /* buffer */
\par 
\par \hich\af1\dbch\af2\loch\f1     h = handle;
\par \hich\af1\dbch\af2\loch\f1     if ((buf = h->curBuf) == NULL) return bErrKeyNotFound;
\par \hich\af1\dbch\af2\loch\f1     fkey = fkey(buf);
\par \hich\af1\dbch\af2\loch\f1     if (h->curKey == fkey) \{
\par \hich\af1\dbch\af2\loch\f1         /* current key is first key in lea\hich\af1\dbch\af2\loch\f1 f node */
\par \hich\af1\dbch\af2\loch\f1         if (prev(buf)) \{
\par \hich\af1\dbch\af2\loch\f1             /* fetch previous set */
\par \hich\af1\dbch\af2\loch\f1             if ((rc = readDisk(prev(buf), &buf)) != 0) return rc;
\par \hich\af1\dbch\af2\loch\f1             pkey = fkey(buf) + ks((ct(buf) - 1));
\par \hich\af1\dbch\af2\loch\f1         \} else \{
\par \hich\af1\dbch\af2\loch\f1             /* no more sets */
\par \hich\af1\dbch\af2\loch\f1             return b\hich\af1\dbch\af2\loch\f1 ErrKeyNotFound;
\par \hich\af1\dbch\af2\loch\f1         \}
\par \hich\af1\dbch\af2\loch\f1     \} else \{
\par \hich\af1\dbch\af2\loch\f1         /* bump to previous key */
\par \hich\af1\dbch\af2\loch\f1         pkey = h->curKey - ks(1);
\par \hich\af1\dbch\af2\loch\f1     \}
\par \hich\af1\dbch\af2\loch\f1     memcpy(key, key(pkey), h->keySize);
\par \hich\af1\dbch\af2\loch\f1     *rec = rec(pkey);
\par \hich\af1\dbch\af2\loch\f1     h->curBuf = buf; h->curKey = pkey;
\par \hich\af1\dbch\af2\loch\f1     return bErrOk;
\par \}
\par 
\par \hich\af1\dbch\af2\loch\f1 int comp(const void\hich\af1\dbch\af2\loch\f1  *key1, const void *key2) \{
\par \hich\af1\dbch\af2\loch\f1     unsigned int const *p1;
\par \hich\af1\dbch\af2\loch\f1     unsigned int const *p2;
\par \hich\af1\dbch\af2\loch\f1     p1 = key1; p2 = key2;
\par \hich\af1\dbch\af2\loch\f1     return (*p1 == *p2) ? CC_EQ : (*p1 > *p2 ) ? }{\f1\lang1031\langfe1040\langnp1031 \hich\af1\dbch\af2\loch\f1 CC_GT : CC_LT;
\par }{\f1\lang1036\langfe1040\langnp1036 \}
\par 
\par \hich\af1\dbch\af2\loch\f1 int main(void) \{
\par \hich\af1\dbch\af2\loch\f1     }{\f1\lang2057\langfe1040\langnp2057 \hich\af1\dbch\af2\loch\f1 bOpenType info;
\par \hich\af1\dbch\af2\loch\f1     bHandleType handle;
\par \hich\af1\dbch\af2\loch\f1     bErrType rc;
\par \hich\af1\dbch\af2\loch\f1  \hich\af1\dbch\af2\loch\f1    unsigned int key;
\par 
\par \hich\af1\dbch\af2\loch\f1     \hich\af1\dbch\af2\loch\f1 remove("t1.dat");
\par 
\par \hich\af1\dbch\af2\loch\f1     info.iName = "t1.dat";
\par \hich\af1\dbch\af2\loch\f1     \hich\af1\dbch\af2\loch\f1 info.keySize = sizeof(int);
\par \hich\af1\dbch\af2\loch\f1     info.sectorSize = 256;
\par \hich\af1\dbch\af2\loch\f1     info.comp = comp;
\par \hich\af1\dbch\af2\loch\f1     if ((rc = bOpen(info, &handle)) != bErrOk) \{
\par \hich\af1\dbch\af2\loch\f1         printf("line %d: rc = %d\\n", __LINE__, rc);
\par \hich\af1\dbch\af2\loch\f1         exit(0);
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     key = 0x11;
\par \hich\af1\dbch\af2\loch\f1     if ((rc = bInsertKey(handle, &key,\hich\af1\dbch\af2\loch\f1  0x300)) != bErrOk) \{
\par \hich\af1\dbch\af2\loch\f1         printf("line %d: rc = %d\\n", __LINE__, rc);
\par \hich\af1\dbch\af2\loch\f1         exit(0);
\par \hich\af1\dbch\af2\loch\f1     \}
\par 
\par \hich\af1\dbch\af2\loch\f1     bClose(handle);
\par 
\par \hich\af1\dbch\af2\loch\f1     printf("statistics:\\n");
\par \hich\af1\dbch\af2\loch\f1     printf("    maximum height: %8d\\n", maxHeight);
\par \hich\af1\dbch\af2\loch\f1     printf("    nodes inserted: %8d\\n", nNodesIns);
\par \hich\af1\dbch\af2\loch\f1     \hich\af1\dbch\af2\loch\f1 printf("    nodes deleted:  %8d\\n", nNodesDel);
\par \hich\af1\dbch\af2\loch\f1     printf("    keys inserted:  %8d\\n", nKeysIns);
\par \hich\af1\dbch\af2\loch\f1     printf("    keys deleted:   %8d\\n", nKeysDel);
\par \hich\af1\dbch\af2\loch\f1     printf("    disk reads:     %8d\\n", nDiskReads);
\par \hich\af1\dbch\af2\loch\f1     printf("    disk writes:    %8d\\n", nDiskWrites);
\par 
\par \hich\af1\dbch\af2\loch\f1     }{\f1 \hich\af1\dbch\af2\loch\f1 return 0;
\par \}
\par 
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1040\langfe1040\cgrid\langnp1040\langfenp1040 {\f1\fs20 
\par }}